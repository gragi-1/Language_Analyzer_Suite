Terminales = { boolean else float function if int let read return string void write floatconst intconst str idint idfl idbool idstr idfun += = , ; ( ) { } + && < boolconst eof }
// Terminales código de los tokens

// No Terminales para funcionalidad, aparte existe lambda
NoTerminales = { S AF AB A Tipo Id Igualar IgualarPre Descriptor Entero IntRecur TermInt TermInt2 Real FlRecur TermFl TermFl2 Booleano BoolRecur TermBool Cadena LlamarFuncion ArgPre ArgRec WriteAlt Cond ARec CondEl ElseAux DefFuncion Arg ArgAux AFuncion AFuncionVoid DefFuncionAux DescripFun Num If2 Else2 AIfPre ElseAux2 AIf IfVoid ElseVoid AIfPreVoid ElseAuxVoid AIfVoid EOF }

// Axioma por defecto
Axioma = S

Producciones = {
    S -> AF EOF

    EOF -> eof
    EOF -> lambda

    AF -> AB
    AF -> DefFuncion 							    // Separado para no poder definir funciones dentro de otras funciones o condicionales
    AF -> lambda

    AB -> A ;
    AB -> if ( Booleano ) Cond

    A -> let Tipo Id Igualar
    A -> Id IgualarPre
    A -> LlamarFuncion 
    A -> read Id
    A -> write WriteAlt

    Num -> Entero
    Num -> Real

    Tipo -> int
    Tipo -> float
    Tipo -> string
    Tipo -> boolean

    Id -> idint
    Id -> idfl
    Id -> idbool
    Id -> idstr

    IgualarPre -> Igualar
    IgualarPre -> += Num

    Igualar -> = Descriptor
    Igualar -> lambda

    Descriptor -> Num 							    // Para no duplicar entre enteros y reales
    Descriptor -> Booleano
    Descriptor -> Cadena

    Entero -> TermInt IntRecur

    IntRecur -> + TermInt2 IntRecur 				// Para poder +ar en la misma línea
    IntRecur -> lambda

    TermInt -> idint
    TermInt -> intconst
    TermInt -> LlamarFuncion + TermInt2

    TermInt2 -> idint
    TermInt2 -> intconst
    TermInt2 -> LlamarFuncion

    Real -> TermFl FlRecur 							// Igual que para los enteros

    FlRecur -> + TermFl2 FlRecur
    FlRecur -> lambda

    TermFl -> idfl
    TermFl -> floatconst
    TermFl -> LlamarFuncion + TermFl2

    TermFl2 -> idfl
    TermFl2 -> floatconst
    TermFl2 -> LlamarFuncion

    Booleano -> TermBool BoolRecur

    BoolRecur -> && TermBool BoolRecur
    BoolRecur -> lambda

    TermBool -> idbool
    TermBool -> boolconst
    TermBool -> Entero < Entero 					// Para comparar operaciones de enteros y reales
    TermBool -> Real < Real
    TermBool -> LlamarFuncion 						// Para conseguir poder llamar exclusivamente a una función

    Cadena -> idstr
    Cadena -> str

    LlamarFuncion -> idfun ( ArgPre )

    ArgPre -> Descriptor ArgRec 					// Para asegurarse que solo haya una opción de ningún argumento
    ArgPre -> lambda

    ArgRec -> , Descriptor ArgRec
    ArgRec -> lambda

    WriteAlt -> Descriptor
    WriteAlt -> ( Descriptor ArgRec )

    Cond -> AB CondEl 							    // Condicional simple
    Cond -> ; CondEl 							    // Para poder dejarlo vacío
    Cond -> { ARec } CondEl 						// Condicional complejo, se pone una A para asegurar al menos un argumento

    ARec -> AB ARec
    ARec -> lambda

    CondEl -> else ElseAux 							// Para poder poner else en los ifs
    CondEl -> lambda

    ElseAux -> AB 							        // Else simple
    ElseAux -> ; 							        // Para poder dejarlo vacío
    ElseAux -> { ARec } 							// Else complejo

    DefFuncion -> function DefFuncionAux }

    DefFuncionAux -> Tipo DescripFun AFuncion
    DefFuncionAux -> void DescripFun AFuncionVoid

    DescripFun -> idfun ( Arg ) {

    Arg -> Tipo Id ArgAux
    Arg -> lambda

    ArgAux -> , Tipo Id ArgAux 						// Se hace un auxiliar exclusivamente por la coma
    ArgAux -> lambda

    AFuncion -> A ; AFuncion
    AFuncion -> if ( Booleano ) If2
    AFuncion -> return Descriptor ; 				// No se ha implementado el caso de los return dentro de condicionales

    AFuncionVoid -> A AFuncionVoid
    AFuncionVoid -> if ( Booleano ) IfVoid
    AFuncionVoid -> return ; 						// Para poder poner un return vacío
    AFuncionVoid -> lambda

    If2 -> AIfPre Else2 							// Condicional simple
    If2 -> { AIf } Else2 							// Condicional complejo, se pone una A para asegurar al menos un argumento

    Else2 -> else ElseAux2 							// Para poder poner else en los ifs
    Else2 -> lambda

    AIfPre -> A ; AIf
    AIfPre -> If2 AIf
    AIfPre -> ;

    AIf -> A ; AIf
    AIf -> return Descriptor ;
    AIf -> If2 AIf
    AIf -> lambda

    ElseAux2 -> AIfPre 							    // Else simple
    ElseAux2 -> { AIfPre } 							// Else complejo

    IfVoid -> AIfPreVoid ElseVoid 					// Condicional simple
    IfVoid -> { AIfVoid } ElseVoid 					// Condicional complejo, se pone una A para asegurar al menos un argumento

    ElseVoid -> else ElseAuxVoid 					// Para poder poner else en los ifs
    ElseVoid -> lambda

    AIfPreVoid -> A ; AIfVoid
    AIfPreVoid -> IfVoid AIfVoid
    AIfPreVoid -> ;

    AIfVoid -> A ; AIfVoid
    AIfVoid -> return ;
    AIfVoid -> IfVoid AIfVoid
    AIfVoid -> lambda

    ElseAuxVoid -> AIfPreVoid 						// Else simple
    ElseAuxVoid -> { AIfPreVoid } 					// Else complejo
}
