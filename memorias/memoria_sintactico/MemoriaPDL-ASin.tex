\documentclass[12pt,twoside,letterpaper]{article}
%NOTE: This report format is 
\setlength{\footskip}{1.5cm}

% report information

\newcommand{\reporttitle}{Procesadores de Lenguajes: Memoria del Proyecto}
\newcommand{\reportauthorOne}{Jose Luis Prado Sierra }
\newcommand{\cidOne}{220070}
\newcommand{\reportauthorTwo}{Alejandro Gragera Serradilla }
\newcommand{\cidTwo}{22M043}
\newcommand{\reportauthorThree}{Antonio Bielza Díez }
\newcommand{\cidThree}{22M049}
\newcommand{\reporttype}{Coursework}

% include files that load packages and define macros
\input{includes} % various packages needed for maths etc.
\input{notation} % short-hand notation and macros


%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\raggedbottom
\begin{document}
% front page
\input{titlepage}


%%%%%%%%%%%%%%%%%%%%%%%%%%% table of content
%If a table of content is needed, simply uncomment the following lines
%\tableofcontents
%\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%% Main document
%\section*{Note:}
%\emph{This document is intended to provide a sample structure for the reports in ME303 at the University of Waterloo. }

\section{Analizador Sintáctico}

Durante el desarrollo del Analizador Sintáctico hemos descrito una gramática y desarrollado un programa que, junto al analizador léxico, es capaz de reconocer y analizar correctamente el lenguaje planteado para el desarrollo de la práctica.

\subsection{Gramática}

La gramática planteada para el desarrollo de Analizador Sintáctico es de tipo 2 segun la jerarquía de Chomsky, es decir, una gramática libre de contexto. Además cumple con las propiedadees necesarias para ser LL(1), lo que nos permite desarrollar un analizador sintáctico predictivo.
\subsubsection{Descripción de la Gramática}
Teniendo todo lo anterior en cuenta, la gramática definida es la siguiente:
\begin{enumerate}[label=\textbf{\arabic*:}]
  \item \texttt{S} $\to$ \texttt{LC S | LF S | eof}
  \item \texttt{LC} $\to$ \texttt{LS semicolon | if oppar Expresion clpar CuerpoIf | else CuerpoIf}
  \item \texttt{LF} $\to$ \texttt{function TypeFun id oppar Args clpar opbra Cuerpo clbra}
  \item \texttt{CuerpoIf} $\to$ \texttt{opbra Cuerpo clbra | LC}
  \item \texttt{Cuerpo} $\to$ \texttt{LC Cuerpo |} $\lambda$
  \item \texttt{Args} $\to$ \texttt{Tipo id ArgMore | void}
  \item \texttt{ArgsLlamada} $\to$ \texttt{Expresion ArgMoreLlamada |} $\lambda$
  \item \texttt{ArgMoreLlamada} $\to$ \texttt{comma Expresion ArgMoreLlamada |} $\lambda$
  \item \texttt{ArgMore} $\to$ \texttt{comma Tipo id ArgMore |} $\lambda$
  \item \texttt{LS} $\to$ \texttt{let Tipo id Asignar | id IdOpt | read id | write Expresion | return ExpReturn}
  \item \texttt{IdOpt} $\to$ \texttt{oppar ArgsLlamada clpar | eq Expresion | pluseq Expresion}
  \item \texttt{TypeFun} $\to$ \texttt{void | Tipo}
  \item \texttt{Tipo} $\to$ \texttt{int | float | string | boolean}
  \item \texttt{Asignar} $\to$ \texttt{eq Expresion |} $\lambda$
  \item \texttt{ExpReturn} $\to$ \texttt{Expresion |} $\lambda$
  \item \texttt{Expresion} $\to$ \texttt{Expresion1 ExpresionAux}
  \item \texttt{ExpresionAux} $\to$ \texttt{and Expresion |} $\lambda$
  \item \texttt{Expresion1} $\to$ \texttt{Expresion2 Expresion1Aux}
  \item \texttt{Expresion1Aux} $\to$ \texttt{minorthan Expresion1 |} $\lambda$
  \item \texttt{Expresion2} $\to$ \texttt{Expresion3 Expresion2Aux}
  \item \texttt{Expresion2Aux} $\to$ \texttt{sum Expresion2 |} $\lambda$
  \item \texttt{Expresion3} $\to$ \texttt{oppar Expresion clpar | intconst | realconst | string | true | false | id Expresion4}
  \item \texttt{Expresion4} $\to$ \texttt{oppar ArgsLlamada clpar |} $\lambda$
\end{enumerate}

\subsubsection{Demostración de que la gramática es LL(1)}

\subsubsection{Tabla LL y Pseudocódigo}
En esta sección se describe la tabla en un formato propio (una tabla normal en LaTeX no cabe) que fue generada siguiendo el pseudocódigo descrito en los apuntes de la asignatura. 

El formato es de la siguiente forma: \textbf{M[Fila, Columna] = Producción} \\\\
M[S, let] = LC S

M[S, read] = LC S

M[S, id] = LC S

M[S, else] = LC S

M[S, if] = LC S

M[S, write] = LC S

M[S, function] = LF S

M[S, return] = LC S

M[S, eof] = eof
\\\\
M[LC, return] = LS semicolon

M[LC, let] = LS semicolon

M[LC, read] = LS semicolon

M[LC, id] = LS semicolon

M[LC, write] = LS semicolon

M[LC, if] = if oppar Expresion clpar CuerpoIf

M[LC, else] = else CuerpoIf
\\\\
M[LF, function] = function TypeFun id oppar Args clpar opbra Cuerpo clbra
\\\\
M[CuerpoIf, opbra] = opbra Cuerpo clbra

M[CuerpoIf, return] = LC

M[CuerpoIf, let] = LC

M[CuerpoIf, read] = LC

M[CuerpoIf, id] = LC

M[CuerpoIf, else] = LC

M[CuerpoIf, if] = LC

M[CuerpoIf, write] = LC
\\\\
M[Cuerpo, return] = LC Cuerpo

M[Cuerpo, let] = LC Cuerpo

M[Cuerpo, read] = LC Cuerpo

M[Cuerpo, id] = LC Cuerpo

M[Cuerpo, else] = LC Cuerpo

M[Cuerpo, if] = LC Cuerpo

M[Cuerpo, write] = LC Cuerpo

M[Cuerpo, clbra] = lambda
\\\\
M[Args, int] = Tipo id ArgMore

M[Args, float] = Tipo id ArgMore

M[Args, boolean] = Tipo id ArgMore

M[Args, string] = Tipo id ArgMore

M[Args, void] = void
\\\\
M[ArgsLlamada, true] = Expresion ArgMoreLlamada

M[ArgsLlamada, string] = Expresion ArgMoreLlamada

M[ArgsLlamada, id] = Expresion ArgMoreLlamada

M[ArgsLlamada, intconst] = Expresion ArgMoreLlamada

M[ArgsLlamada, oppar] = Expresion ArgMoreLlamada

M[ArgsLlamada, false] = Expresion ArgMoreLlamada

M[ArgsLlamada, realconst] = Expresion ArgMoreLlamada

M[ArgsLlamada, clpar] = lambda
\\\\
M[ArgMoreLlamada, comma] = comma Expresion ArgMoreLlamada

M[ArgMoreLlamada, clpar] = lambda
\\\\
M[ArgMore, comma] = comma Tipo id ArgMore

M[ArgMore, clpar] = lambda
\\\\
M[LS, let] = let Tipo id Asignar

M[LS, id] = id IdOpt

M[LS, read] = read id

M[LS, write] = write Expresion

M[LS, return] = return ExpReturn
\\\\
M[IdOpt, oppar] = oppar ArgsLlamada clpar

M[IdOpt, eq] = eq Expresion

M[IdOpt, pluseq] = pluseq Expresion
\\\\
M[TypeFun, void] = void

M[TypeFun, int] = Tipo

M[TypeFun, float] = Tipo

M[TypeFun, boolean] = Tipo

M[TypeFun, string] = Tipo
\\\\
M[Tipo, int] = int

M[Tipo, float] = float

M[Tipo, string] = string

M[Tipo, boolean] = boolean
\\\\
M[Asignar, eq] = eq Expresion

M[Asignar, semicolon] = lambda
\\\\
M[ExpReturn, true] = Expresion

M[ExpReturn, string] = Expresion

M[ExpReturn, id] = Expresion

M[ExpReturn, intconst] = Expresion

M[ExpReturn, oppar] = Expresion

M[ExpReturn, false] = Expresion

M[ExpReturn, realconst] = Expresion

M[ExpReturn, semicolon] = lambda
\\\\
M[Expresion, true] = Expresion1 ExpresionAux

M[Expresion, string] = Expresion1 ExpresionAux

M[Expresion, id] = Expresion1 ExpresionAux

M[Expresion, intconst] = Expresion1 ExpresionAux

M[Expresion, oppar] = Expresion1 ExpresionAux

M[Expresion, false] = Expresion1 ExpresionAux

M[Expresion, realconst] = Expresion1 ExpresionAux
\\\\
M[ExpresionAux, and] = and Expresion

M[ExpresionAux, semicolon] = lambda

M[ExpresionAux, clpar] = lambda

M[ExpresionAux, comma] = lambda
\\\\
M[Expresion1, true] = Expresion2 Expresion1Aux

M[Expresion1, string] = Expresion2 Expresion1Aux

M[Expresion1, id] = Expresion2 Expresion1Aux

M[Expresion1, intconst] = Expresion2 Expresion1Aux

M[Expresion1, oppar] = Expresion2 Expresion1Aux

M[Expresion1, false] = Expresion2 Expresion1Aux

M[Expresion1, realconst] = Expresion2 Expresion1Aux
\\\\
M[Expresion1Aux, minorthan] = minorthan Expresion1

M[Expresion1Aux, and] = lambda

M[Expresion1Aux, semicolon] = lambda

M[Expresion1Aux, clpar] = lambda

M[Expresion1Aux, comma] = lambda
\\\\
M[Expresion2, true] = Expresion3 Expresion2Aux

M[Expresion2, string] = Expresion3 Expresion2Aux

M[Expresion2, id] = Expresion3 Expresion2Aux

M[Expresion2, intconst] = Expresion3 Expresion2Aux

M[Expresion2, oppar] = Expresion3 Expresion2Aux

M[Expresion2, false] = Expresion3 Expresion2Aux

M[Expresion2, realconst] = Expresion3 Expresion2Aux
\\\\
M[Expresion2Aux, sum] = sum Expresion2

M[Expresion2Aux, and] = lambda

M[Expresion2Aux, clpar] = lambda

M[Expresion2Aux, semicolon] = lambda

M[Expresion2Aux, comma] = lambda

M[Expresion2Aux, minorthan] = lambda
\\\\
M[Expresion3, oppar] = oppar Expresion clpar

M[Expresion3, intconst] = intconst

M[Expresion3, realconst] = realconst

M[Expresion3, string] = string

M[Expresion3, true] = true

M[Expresion3, false] = false

M[Expresion3, id] = id Expresion4
\\\\
M[Expresion4, oppar] = oppar ArgsLlamada clpar

M[Expresion4, and] = lambda

M[Expresion4, sum] = lambda

M[Expresion4, clpar] = lambda

M[Expresion4, comma] = lambda

M[Expresion4, semicolon] = lambda

M[Expresion4, minorthan] = lambda

\subsection{Errores}

Todo buen procesador de lenguajes debe de avisar al usuario de si existe algún error y además es capaz de tratar todos los posibles errores para una ejecución robusta y comprensible. 
\\
Sin embargo para esta entrega no es necesario que sean descriptivos pero si han de ser reconocidos y clasificados.
\\
\\
Hemos detectado los siguientes casos capaces de generar errores:
\begin{itemize}[itemsep=0.0em, topsep=0.5em]
    \item \textbf{Cadena mal cerrada:} Al iniciar una cadena si queda mal cerrada (Ej. 'Hola buenas tardes).
    \item \textbf{ID incorrecto:} Al generar o utilizar un ID si los caracteres que lo componen no son correctos.
    \item \textbf{Caracter no reconocido:} Si se recibe un caracter no válido en el estado inicial.
    \item \textbf{Operador lógico incorrecto:} Si se pone un operador lógico (como \&\&) de forma incorrecta (Ej. \&).
    \item \textbf{Comentario de línea mal iniciado:} Al iniciar un comentario de línea incorrectamente (Ej. /Hola buenas tardes).
    \item \textbf{Entero demasiado grande:} Al declarar un entero mayor que 32767.
    \item \textbf{Real demasiado grande:} Al declarar un real mayor que 117549436.
    \item \textbf{Cadena demasiado grande:} Al declarar una cadena de más de 64 caracteres.
\end{itemize}

\newpage
\section{Anexo}

\subsection{Casos Correctos}

\subsubsection{Caso Correcto}
\begin{itemize}[label={-}, itemsep=-1em, topsep=0.5em, parsep=-0.2em]
    \item \textbf{Código:}
    \begin{verbatim} 
let int a_53f = 3;
let boolean bb;
let float fl = 3.5;
let int c;
let float fl2;
c = a_53f + 9;
fl2 = fl + 3.0;
let string str = 'Supercalifragilisticoespialidoso';
    \end{verbatim}
    \item \textbf{Archivo de Tokens:}\begin{verbatim}
<LET,>
<INT,>
<ID,0>
<EQ,>
<INTCONST,3>
<SEMICOLON,>
<LET,>
<BOOLEAN,>
<ID,1>
<SEMICOLON,>
<LET,>
<FLOAT,>
<ID,2>
<EQ,>
<REALCONST,3.5>
<SEMICOLON,>
<LET,>
<INT,>
<ID,3>
<SEMICOLON,>
<LET,>
<FLOAT,>
<ID,4>
<SEMICOLON,>
<ID,5>
<EQ,>
<ID,6>
<SUM,>
<INTCONST,9>
<SEMICOLON,>
<ID,7>
<EQ,>
<ID,8>
<SUM,>
<REALCONST,3.0>
<SEMICOLON,>
<LET,>
<STRING,>
<ID,9>
<EQ,>
<STR,"Supercalifragilisticoespialidoso">
<SEMICOLON,>
<EOF,>
    \end{verbatim}
    \item \textbf{Archivo de Tabla de Símbolos:}\begin{verbatim}
CONTENIDOS DE LA TABLA # 1:
* LEXEMA : 'a_53f'
  Atributos:
--------- ---------
* LEXEMA : 'bb'
  Atributos:
--------- ---------
* LEXEMA : 'fl'
  Atributos:
--------- ---------
* LEXEMA : 'c'
  Atributos:
--------- ---------
* LEXEMA : 'fl2'
  Atributos:
--------- ---------
* LEXEMA : 'str'
  Atributos:
--------- ---------
    \end{verbatim}
\end{itemize}

\subsubsection{Caso Correcto}
\begin{itemize}[label={-}, itemsep=-1em, topsep=0.5em, parsep=-0.2em]
    \item \textbf{Código:}
    \begin{verbatim} 
let int s = 2; // Esto es una prueba de comentario 4hjdsh2&&ndj!
s = s + 3; // Sigue siendo una prueba jdlwn;eldr4,4nc,erioe4nx,(·!N$"()E·/$"N
let boolean bs = s && 4;
    \end{verbatim}
    \item \textbf{Archivo de Tokens:}
    \begin{verbatim} 
<LET,>
<INT,>
<ID,0>
<EQ,>
<INTCONST,2>
<SEMICOLON,>
<ID,1>
<EQ,>
<ID,2>
<SUM,>
<INTCONST,3>
<SEMICOLON,>
<LET,>
<BOOLEAN,>
<ID,3>
<EQ,>
<ID,4>
<AND,>
<INTCONST,4>
<SEMICOLON,>
<EOF,>
    \end{verbatim}
    \item \textbf{Archivo de Tabla de Símbolos:}
    \begin{verbatim} 
CONTENIDOS DE LA TABLA # 1:
* LEXEMA : 's'
  Atributos:
--------- ---------
* LEXEMA : 'bs'
  Atributos:
--------- ---------
    \end{verbatim}
\end{itemize}

\newpage
\subsubsection{Caso Correcto}
\begin{itemize}[label={-}, itemsep=-1em, topsep=0.5em, parsep=-0.2em]
    \item \textbf{Código:}
    \begin{verbatim} 
function void sql {
	lt boolean b = true;
		let int dl = 7;
	if (b == true) {
		dl = dl + 2;
		write('Sí');
	}
	else return;
}
    \end{verbatim}
    \item \textbf{Archivo de Tokens:}
    \begin{verbatim} 
<FUNCTION,>
<VOID,>
<ID,0>
<OPBRA,>
<ID,1>
<BOOLEAN,>
<ID,2>
<EQ,>
<TRUE,>
<SEMICOLON,>
<LET,>
<INT,>
<ID,3>
<EQ,>
<INTCONST,7>
<SEMICOLON,>
<IF,>
<OPPAR,>
<ID,4>
<EQ,>
<EQ,>
<TRUE,>
<CLPAR,>
<OPBRA,>
<ID,5>
<EQ,>
<ID,6>
<SUM,>
<INTCONST,2>
<SEMICOLON,>
<WRITE,>
<OPPAR,>
<STR,"Sí">
<CLPAR,>
<SEMICOLON,>
<CLBRA,>
<ELSE,>
<RETURN,>
<SEMICOLON,>
<CLBRA,>
<EOF,>
    \end{verbatim}
    \item \textbf{Archivo de Tabla de Símbolos:}
    \begin{verbatim} 
CONTENIDOS DE LA TABLA # 1:
* LEXEMA : 'sql'
  Atributos:
--------- ---------
* LEXEMA : 'lt'
  Atributos:
--------- ---------
* LEXEMA : 'b'
  Atributos:
--------- ---------
* LEXEMA : 'dl'
  Atributos:
--------- ---------
    \end{verbatim}
\end{itemize}

\newpage
\subsection{Casos Erróneos}
\subsubsection{Caso Erróneo}
\begin{itemize}[label={-}, itemsep=-1em, topsep=0.5em, parsep=-0.2em]
    \item \textbf{Código:}
    \begin{verbatim} 
let int _ser = 45;
let float fl = 564.;
let boolean bl = true;
if (bl & false) int = 3;
    \end{verbatim}
    \item \textbf{Errores:}
    \begin{verbatim} 
Carácter ilegal '.' en línea 2 
Carácter ilegal '&' en línea 4
    \end{verbatim}
\end{itemize}

\subsubsection{Caso Erróneo}
\begin{itemize}[label={-}, itemsep=-1em, topsep=0.5em, parsep=-0.2em]
    \item \textbf{Código:}
    \begin{verbatim} 
let boolean xl3_ = false; / Doremifasollasido
let int del = 3;
del += 4;
if (xl3 == false) write('A'),
    \end{verbatim}
    \item \textbf{Error:}
    \begin{verbatim} 
    Carácter ilegal '/' en línea 1
    \end{verbatim}
\end{itemize}

\subsubsection{Caso Erróneo}
\begin{itemize}[label={-}, itemsep=-1em, topsep=0.0em, parsep=-0.2em]
    \item \textbf{Código:}
    \begin{verbatim} 
let int 3m = 56;
let float ad&d = 3.4;
if (ad&d < 3m) write('Error);
return ad&d;
    \end{verbatim}
    \item \textbf{Errores:}
    \begin{verbatim} 
Carácter ilegal '&' en línea 2
Carácter ilegal '&' en línea 3
Carácter ilegal "'" en línea 3
Carácter ilegal '&' en línea 4
    \end{verbatim}
\end{itemize}


\begin{figure}[h!]
\centering
\includegraphics[width=0.45\textwidth]{../figures/goose.png} 
\caption{Barnacla canadiense intencional.}
\end{figure}

\end{document}
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
