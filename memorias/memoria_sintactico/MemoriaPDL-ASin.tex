\documentclass[12pt,twoside,letterpaper]{article}
%NOTE: This report format is 
\setlength{\footskip}{1.5cm}

% report information

\newcommand{\reporttitle}{Procesadores de Lenguajes: Memoria del Proyecto}
\newcommand{\reportauthorOne}{Jose Luis Prado Sierra }
\newcommand{\cidOne}{220070}
\newcommand{\reportauthorTwo}{Alejandro Gragera Serradilla }
\newcommand{\cidTwo}{22M043}
\newcommand{\reportauthorThree}{Antonio Bielza Díez }
\newcommand{\cidThree}{22M049}
\newcommand{\reporttype}{Coursework}

% include files that load packages and define macros
\input{includes} % various packages needed for maths etc.
\input{notation} % short-hand notation and macros


%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\raggedbottom
\begin{document}
% front page
\input{titlepage}


%%%%%%%%%%%%%%%%%%%%%%%%%%% table of content
%If a table of content is needed, simply uncomment the following lines
\tableofcontents
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%% Main document
%\section*{Note:}
%\emph{This document is intended to provide a sample structure for the reports in ME303 at the University of Waterloo. }

\section{Analizador Sintáctico}

Durante el desarrollo del Analizador Sintáctico hemos descrito una gramática y desarrollado un programa que, junto al analizador léxico, es capaz de reconocer y analizar correctamente el lenguaje planteado para el desarrollo de la práctica.

\subsection{Gramática}

La gramática planteada para el desarrollo de Analizador Sintáctico es de tipo 2 segun la jerarquía de Chomsky, es decir, una gramática libre de contexto. Además cumple con las propiedadees necesarias para ser LL(1), lo que nos permite desarrollar un analizador sintáctico predictivo.
\\\\
Teniendo todo lo anterior en cuenta, la gramática definida es la siguiente:
\begin{enumerate}[label=\textbf{\arabic*:}]
  \item \texttt{S} $\to$ \texttt{LC S | LF S | eof}
  \item \texttt{LC} $\to$ \texttt{LS semicolon | if oppar Expresion clpar CuerpoIf | else CuerpoIf}
  \item \texttt{LF} $\to$ \texttt{function TypeFun id oppar Args clpar opbra Cuerpo clbra}
  \item \texttt{CuerpoIf} $\to$ \texttt{opbra Cuerpo clbra | LC}
  \item \texttt{Cuerpo} $\to$ \texttt{LC Cuerpo |} $\lambda$
  \item \texttt{Args} $\to$ \texttt{Tipo id ArgMore | void}
  \item \texttt{ArgsLlamada} $\to$ \texttt{Expresion ArgMoreLlamada |} $\lambda$
  \item \texttt{ArgMoreLlamada} $\to$ \texttt{comma Expresion ArgMoreLlamada |} $\lambda$
  \item \texttt{ArgMore} $\to$ \texttt{comma Tipo id ArgMore |} $\lambda$
  \item \texttt{LS} $\to$ \texttt{let Tipo id Asignar | id IdOpt | read id | write Expresion | return ExpReturn}
  \item \texttt{IdOpt} $\to$ \texttt{oppar ArgsLlamada clpar | eq Expresion | pluseq Expresion}
  \item \texttt{TypeFun} $\to$ \texttt{void | Tipo}
  \item \texttt{Tipo} $\to$ \texttt{int | float | string | boolean}
  \item \texttt{Asignar} $\to$ \texttt{eq Expresion |} $\lambda$
  \item \texttt{ExpReturn} $\to$ \texttt{Expresion |} $\lambda$
  \item \texttt{Expresion} $\to$ \texttt{Expresion1 ExpresionAux}
  \item \texttt{ExpresionAux} $\to$ \texttt{and Expresion |} $\lambda$
  \item \texttt{Expresion1} $\to$ \texttt{Expresion2 Expresion1Aux}
  \item \texttt{Expresion1Aux} $\to$ \texttt{minorthan Expresion1 |} $\lambda$
  \item \texttt{Expresion2} $\to$ \texttt{Expresion3 Expresion2Aux}
  \item \texttt{Expresion2Aux} $\to$ \texttt{sum Expresion2 |} $\lambda$
  \item \texttt{Expresion3} $\to$ \texttt{oppar Expresion clpar | intconst | realconst | string | true | false | id Expresion4}
  \item \texttt{Expresion4} $\to$ \texttt{oppar ArgsLlamada clpar |} $\lambda$
\end{enumerate}

\subsection{Demostración de que la gramática es LL(1)}


Para demostrar que una gramática es LL(1), debemos verificar que cumple las siguientes propiedades:

\begin{enumerate}[itemsep=0.2em, topsep=0.5em]
    \item No existe recursividad por la izquierda.
    \item Está factorizada por la izquierda.
    \item Para cada no terminal $A$ con producciones alternativas $A \rightarrow \alpha_1 ~|~ \alpha_2 ~|~ \ldots ~|~ \alpha_n$, los conjuntos FIRST($\alpha_{i}$) son disjuntos.
    \item Para cada producción con $\lambda$: $A \rightarrow \alpha ~|~ \lambda$, se cumple que $\text{FIRST}(\alpha) \cap \text{FOLLOW}(A) = \emptyset$.
\end{enumerate}

\subsubsection{Cálculo de Conjuntos FIRST}

El conjunto $\text{FIRST}(\alpha)$ contiene todos los terminales que pueden aparecer al inicio de una derivación desde $\alpha$.

\vspace{0.3em}
\textbf{Conjuntos FIRST principales:}
\begin{align*}
\text{FIRST}(Tipo) ={}& \{\mathit{int}, \mathit{float}, \mathit{string}, \mathit{boolean}\} \\
\text{FIRST}(TypeFun) ={}& \{\mathit{void}, \mathit{int}, \mathit{float}, \mathit{string}, \mathit{boolean}\} \\
\text{FIRST}(LS) ={}& \{\mathit{let}, \mathit{id}, \mathit{read}, \mathit{write}, \mathit{return}\} \\
\text{FIRST}(LC) ={}& \{\mathit{let}, \mathit{id}, \mathit{read}, \mathit{write}, \mathit{return}, \mathit{if}, \mathit{else}\} \\
\text{FIRST}(LF) ={}& \{\mathit{function}\} \\
\text{FIRST}(S) ={}& \{\mathit{let}, \mathit{id}, \mathit{read}, \mathit{write}, \mathit{return}, \mathit{if}, \mathit{else}, \mathit{function}, \mathit{eof}\} \\
\text{FIRST}(Expresion3) ={}& \{\mathit{oppar}, \mathit{intconst}, \mathit{realconst}, \mathit{string}, \mathit{true}, \mathit{false}, \mathit{id}\} \\
\text{FIRST}(Expresion2) ={}& \text{FIRST}(Expresion3) \\
\text{FIRST}(Expresion1) ={}& \text{FIRST}(Expresion2) \\
\text{FIRST}(Expresion) ={}& \text{FIRST}(Expresion1) \\
\text{FIRST}(Args) ={}& \{\mathit{int}, \mathit{float}, \mathit{string}, \mathit{boolean}, \mathit{void}\} \\
\text{FIRST}(ArgsLlamada) ={}& \{\mathit{oppar}, \mathit{intconst}, \mathit{realconst}, \mathit{string}, \mathit{true}, \mathit{false}, \mathit{id}, \lambda\} \\
\text{FIRST}(Cuerpo) ={}& \{\mathit{let}, \mathit{id}, \mathit{read}, \mathit{write}, \mathit{return}, \mathit{if}, \mathit{else}, \lambda\} \\
\text{FIRST}(CuerpoIf) ={}& \{\mathit{opbra}, \mathit{let}, \mathit{id}, \mathit{read}, \mathit{write}, \mathit{return}, \mathit{if}, \mathit{else}\}
\end{align*}

\subsubsection{Cálculo de Conjuntos FOLLOW}

El conjunto $\text{FOLLOW}(A)$ contiene todos los terminales que pueden aparecer inmediatamente después de $A$ en alguna derivación.

\vspace{0.3em}
\textbf{Conjuntos FOLLOW principales:}
\begin{align*}
\text{FOLLOW}(S) ={}& \{\mathit{eof}\} \\
\text{FOLLOW}(Cuerpo) ={}& \{\mathit{clbra}\} \\
\text{FOLLOW}(LS) ={}& \{\mathit{semicolon}\} \\
\text{FOLLOW}(Args) ={}& \{\mathit{clpar}\} \\
\text{FOLLOW}(ArgsLlamada) ={}& \{\mathit{clpar}\} \\
\text{FOLLOW}(LC) ={}& \{\mathit{let}, \mathit{id}, \mathit{read}, \mathit{write}, \mathit{return}, \mathit{if}, \mathit{else}, \mathit{function}, \mathit{eof}, \mathit{clbra}\} \\
\text{FOLLOW}(LF) ={}& \{\mathit{let}, \mathit{id}, \mathit{read}, \mathit{write}, \mathit{return}, \mathit{if}, \mathit{else}, \mathit{function}, \mathit{eof}\} \\
\text{FOLLOW}(CuerpoIf) ={}& \{\mathit{let}, \mathit{id}, \mathit{read}, \mathit{write}, \mathit{return}, \mathit{if}, \mathit{else}, \mathit{function}, \mathit{eof}, \mathit{clbra}\} \\
\text{FOLLOW}(Expresion) ={}& \{\mathit{clpar}, \mathit{semicolon}, \mathit{comma}, \mathit{and}, \mathit{minorthan}, \mathit{sum}\}
\end{align*}

\subsubsection{Verificación de la Propiedad LL(1)}

Debemos verificar que para cada no terminal con producciones alternativas, los conjuntos FIRST son disjuntos, y para producciones con $\lambda$, se cumple que $\text{FIRST}(\alpha) \cap \text{FOLLOW}(A) = \emptyset$.

\vspace{0.3em}
\textbf{Caso 1: No terminal $S$}

\begin{center}
\begin{minipage}{0.85\textwidth}
\begin{align*}
S \rightarrow{}& LC~S ~|~ LF~S ~|~ \mathit{eof} \\
\text{FIRST}(LC~S) ={}& \{\mathit{let}, \mathit{id}, \mathit{read}, \mathit{write}, \mathit{return}, \mathit{if}, \mathit{else}\} \\
\text{FIRST}(LF~S) ={}& \{\mathit{function}\} \\
\text{FIRST}(\mathit{eof}) ={}& \{\mathit{eof}\} \quad \text{Los tres conjuntos son disjuntos: } \checkmark
\end{align*}
\end{minipage}
\end{center}


\textbf{Caso 2: No terminal $LC$}
\begin{align*}
LC \rightarrow{}& LS~; ~|~ \mathit{if}~(~\ldots ~|~ \mathit{else}~\ldots \\
\text{FIRST}(LS~;) ={}& \{\mathit{let}, \mathit{id}, \mathit{read}, \mathit{write}, \mathit{return}\} \\
\text{FIRST}(\mathit{if}\ldots) ={}& \{\mathit{if}\} \\
\text{FIRST}(\mathit{else}\ldots) ={}& \{\mathit{else}\} \quad \text{Los tres conjuntos son disjuntos: } \checkmark
\end{align*}

\textbf{Caso 3: No terminal $LS$ (5 producciones)}
\begin{align*}
LS \rightarrow{}& \mathit{let}~\ldots ~|~ \mathit{id}~\ldots ~|~ \mathit{read}~\ldots ~|~ \mathit{write}~\ldots ~|~ \mathit{return}~\ldots \\
\text{FIRST}(\mathit{let}\ldots) ={}& \{\mathit{let}\}, \quad \text{FIRST}(\mathit{id}\ldots) = \{\mathit{id}\}, \quad \text{FIRST}(\mathit{read}\ldots) = \{\mathit{read}\} \\
\text{FIRST}(\mathit{write}\ldots) ={}& \{\mathit{write}\}, \quad \text{FIRST}(\mathit{return}\ldots) = \{\mathit{return}\} \quad \text{Todos disjuntos: } \checkmark
\end{align*}

\textbf{Caso 4: No terminal $Cuerpo$ (con $\lambda$)}
\begin{align*}
Cuerpo \rightarrow{}& LC~Cuerpo ~|~ \lambda \\
\text{FIRST}(LC~Cuerpo) ={}& \{\mathit{let}, \mathit{id}, \mathit{read}, \mathit{write}, \mathit{return}, \mathit{if}, \mathit{else}\} \\
\text{FOLLOW}(Cuerpo) ={}& \{\mathit{clbra}\} \quad \text{Verificación: } \text{FIRST}(LC~Cuerpo) \cap \text{FOLLOW}(Cuerpo) = \emptyset \quad \checkmark
\end{align*}

\textbf{Caso 5: No terminal $ArgsLlamada$ (con $\lambda$)}
\begin{align*}
ArgsLlamada \rightarrow{}& Expresion~ArgMoreLlamada ~|~ \lambda \\
\text{FIRST}(Expresion\ldots) ={}& \{\mathit{oppar}, \mathit{intconst}, \mathit{realconst}, \mathit{string}, \mathit{true}, \mathit{false}, \mathit{id}\} \\
\text{FOLLOW}(ArgsLlamada) ={}& \{\mathit{clpar}\} \quad \text{Verificación: } \text{FIRST}(Expresion\ldots) \cap \text{FOLLOW}(ArgsLlamada) = \emptyset \quad \checkmark
\end{align*}

\textbf{Casos 6 y 7: No terminales $ArgMore$ y $ArgMoreLlamada$ (con $\lambda$)}
\begin{align*}
ArgMore \rightarrow{}& ,~Tipo~id~ArgMore ~|~ \lambda \\
\text{FIRST}(,\ldots) ={}& \{\mathit{comma}\} \quad \text{FOLLOW}(ArgMore) = \{\mathit{clpar}\} \quad \checkmark \\
ArgMoreLlamada \rightarrow{}& ,~Expresion~ArgMoreLlamada ~|~ \lambda \\
\text{FIRST}(,\ldots) ={}& \{\mathit{comma}\} \quad \text{FOLLOW}(ArgMoreLlamada) = \{\mathit{clpar}\} \quad \checkmark
\end{align*}

\textbf{Casos 8 y 9: No terminales $Asignar$ y $ExpReturn$ (con $\lambda$)}
\begin{align*}
Asignar \rightarrow{}& =~Expresion ~|~ \lambda \\
\text{FIRST}(=\ldots) ={}& \{\mathit{eq}\} \quad \text{FOLLOW}(Asignar) = \{\mathit{semicolon}\} \quad \checkmark \\
ExpReturn \rightarrow{}& Expresion ~|~ \lambda \\
\text{FIRST}(Expresion) ={}& \{\mathit{oppar}, \mathit{intconst}, \mathit{realconst}, \mathit{string}, \mathit{true}, \mathit{false}, \mathit{id}\} \\
\text{FOLLOW}(ExpReturn) ={}& \{\mathit{semicolon}\} \quad \text{Verificación: } \text{FIRST}(Expresion) \cap \{\mathit{semicolon}\} = \emptyset \quad \checkmark
\end{align*}

\textbf{Caso 10: No terminales de expresiones (con $\lambda$)}
\begin{align*}
ExpresionAux \rightarrow{}& \mathit{and}~Expresion ~|~ \lambda \\
\text{FIRST}(\mathit{and}\ldots) ={}& \{\mathit{and}\} \quad \text{FOLLOW}(ExpresionAux) = \{\mathit{clpar}, \mathit{semicolon}, \mathit{comma}\} \quad \checkmark \\
Expresion1Aux \rightarrow{}& \mathit{minorthan}~Expresion1 ~|~ \lambda \\
\text{FIRST}(\mathit{minorthan}\ldots) ={}& \{\mathit{minorthan}\} \quad \text{FOLLOW}(Expresion1Aux) = \{\mathit{clpar}, \mathit{semicolon}, \mathit{comma}, \mathit{and}\} \quad \checkmark \\
Expresion2Aux \rightarrow{}& \mathit{sum}~Expresion2 ~|~ \lambda \\
\text{FIRST}(\mathit{sum}\ldots) ={}& \{\mathit{sum}\} \quad \text{FOLLOW}(Expresion2Aux) = \{\mathit{clpar}, \mathit{semicolon}, \mathit{comma}, \mathit{and}, \mathit{minorthan}\} \quad \checkmark \\
Expresion4 \rightarrow{}& (~ArgsLlamada~) ~|~ \lambda \\
\text{FIRST}((\ldots) ={}& \{\mathit{oppar}\} \quad \text{FOLLOW}(Expresion4) = \{\mathit{clpar}, \mathit{semicolon}, \mathit{comma}, \mathit{and}, \mathit{minorthan}, \mathit{sum}\} \quad \checkmark
\end{align*}

\begin{flushright}
$\square$
\end{flushright}

\subsection{Tabla LL y Pseudocódigo}

    El Pseudocódigo del analizador sintáctico predictivo es el siguiente:

    \begin{lstlisting}[]
ALGORITMO ConstruirTablaLL1()
ENTRADA: Gramatica con conjuntos FIRST y FOLLOW calculados
SALIDA: Tabla LL(1) M[A, a]

INICIO
  // Paso 1: Inicializar tabla vacia
  PARA CADA no terminal A EN Gramatica
    PARA CADA terminal a EN Terminales UNION {eof}
      M[A, a] := vacio  // M[A, a] = (produccion, codigo_error)
    FIN PARA
  FIN PARA
  
  // Paso 2: Llenar tabla para cada produccion
  PARA CADA produccion p: A -> X1 X2 ... Xn
    CALCULAR FIRST(X1 X2 ... Xn)
    
    // Paso 2.1: Llenar con FIRST
    PARA CADA terminal a EN FIRST(X1 X2 ... Xn)
      SI M[A, a] != vacio ENTONCES
        ERROR("Conflicto en tabla: entrada M[A, a] ya ocupada")
        RETORNAR falso
      FIN SI
      M[A, a] := p  // Guardar numero de produccion
    FIN PARA
    
    // Paso 2.2: Si lambda EN FIRST(X1 X2 ... Xn)
    SI lambda EN FIRST(X1 X2 ... Xn) ENTONCES
      PARA CADA terminal b EN FOLLOW(A)
        SI M[A, b] != vacio ENTONCES
          ERROR("Conflicto en tabla: entrada M[A, b] ya ocupada")
          RETORNAR falso
        FIN SI
        M[A, b] := p  // Guardar numero de produccion
      FIN PARA
      
      // Paso 2.3: Si eof EN FOLLOW(A)
      SI eof EN FOLLOW(A) ENTONCES
        SI M[A, eof] != vacio ENTONCES
          ERROR("Conflicto en tabla: entrada M[A, eof] ya ocupada")
          RETORNAR falso
        FIN SI
        M[A, eof] := p
      FIN SI
    FIN SI
  FIN PARA
  
  // Paso 3: Marcar entradas de error
  PARA CADA no terminal A
    PARA CADA terminal a
      SI M[A, a] = vacio ENTONCES
        M[A, a] := ERROR  // Marcar como error sintactico
      FIN SI
    FIN PARA
  FIN PARA
  
  RETORNAR verdadero  // Tabla construida exitosamente
FIN
\end{lstlisting}

    Se ha hecho un renombrado de los símbolos de la gramática para favorecer su representación.
    \\\\
    CuerpoIf $\to$ CI \\
    Cuerpo $\to$ CU \\
    Args $\to$ AR \\
    ArgsLlamada $\to$ AL \\
    ArgMore $\to$ AM \\
    ArgMoreLlamada $\to$ AML \\
    IdOpt $\to$ IO \\
    TypeFun $\to$ TF \\
    Tipo $\to$ TI \\
    Asignar $\to$ AS \\
    ExpReturn $\to$ ER \\
    Expresion $\to$ EX \\
    ExpresionAux $\to$ EA \\
    Expresion1 $\to$ E1 \\
    Expresion1Aux $\to$ E1A \\
    Expresion2 $\to$ E2 \\
    Expresion2Aux $\to$ E2A \\
    Expresion3 $\to$ E3 \\
    Expresion4 $\to$ E4 \\

    La tabla por gestión de espacio esta representada en la página \hyperref[sec:tabla]{\pageref*{sec:tabla}} dentro del Anexo.

\subsection{Errores}

Un analizador sintáctico ha de ser capaz de detectar los posibles errores en cada línea y notificarlos de forma clara y localizada al usuario.
\\
Para esta entrega hemos detectado los siguientes casos de error:
\begin{itemize}[itemsep=0.0em, topsep=0.5em]
    \item \textbf{Línea mal terminada:} El analizador detecta que una línea no ha terminado con punto y coma cuando debería.
    \item \textbf{Variable mal declarada:} Cuando a la declaración de una variable le falta alguno de sus componentes: let, tipo...
    \item \textbf{Función mal declarada:} Cuando a la declaración de una función le falta alguno de sus componentes: paréntesis, tipos, comas, corchetes...
    \item \textbf{Función mal llamada:} Cuando se llama a una función de forma incorrecta: sin paréntesis, agregando tipos a las variables...
    \item \textbf{Sentencia if mal declarada:} Cuando una sentencia if no es correcta: multiple línea sin usar corchetes, falta de paréntesis...
    \item \textbf{Sentencia else mal declarada:} Cuando una sentencia else no es correcta, igual que con el if.
    \item \textbf{Expresión mal delcarada:} Cuando la declaración de una expresión de cualquier tipo no es correcta, por ejemplo: (1+2*3 o num1 $<$ ().
\end{itemize}

\newpage
\section{Anexo}

\subsection{Casos Correctos}

\subsubsection{Caso Correcto}
\begin{itemize}[label={-}, itemsep=-1em, topsep=0.5em, parsep=-0.2em]
    \item \textbf{Código:}\begin{verbatim} 
function int calcular(int x, int y) {
    let int temp = x + y;
    if (temp < 100)
        return temp;
}

let int num1 = 10;
let int num2 = 20;
let int resultado = calcular(num1, num2);
write(resultado);

let boolean condicion = num1 < num2;
if (condicion) {
    write('num1 es menor');
}
    \end{verbatim}
    \item \textbf{Volcado Parse:}\\
Descendente 2 7 29 30 12 30 18 30 19 10 4 20 30 34 38 41 44 53 55 45 44 53 55 46 43 40 10 5 38 41 44 53 55 46 42 41 44 48 46 43 40 9 4 24 36 38 41 44 53 55 46 43 40 11 1 4 20 30 34 38 41 44 48 46 43 40 1 4 20 30 34 38 41 44 48 46 43 40 1 4 20 30 34 38 41 44 53 54 14 38 41 44 53 55 46 43 40 16 38 41 44 53 55 46 43 40 17 46 43 40 1 4 23 38 41 44 47 38 41 44 53 55 46 43 40 46 43 40 1 4 20 33 34 38 41 44 53 55 46 42 41 44 53 55 46 43 40 1 5 38 41 44 53 55 46 43 40 8 10 4 23 38 41 44 47 38 41 44 50 46 43 40 46 43 40 11 3 
\\\\
    \item \textbf{Árbol Sintáctico:}
\begin{verbatim}
S (2)
  LF (7)
    function
    TypeFun (29)
      Tipo (30)
        int
    id
    oppar
    Args (12)
      Tipo (30)
        int
      id
      ArgMore (18)
        comma
        Tipo (30)
          int
        id
        ArgMore (19)
          lambda
    clpar
    opbra
    Cuerpo (10)
      LC (4)
        LS (20)
          let
          Tipo (30)
            int
          id
          Asignar (34)
            eq
            Expresion (38)
              Expresion1 (41)
                Expresion2 (44)
                  Expresion3 (53)
                    id
                  Expresion2Aux (45)
                    sum
                    Expresion2 (44)
                      Expresion3 (53)
                        id
                      Expresion2Aux (46)
                        lambda
                Expresion1Aux (43)
                  lambda
              ExpresionAux (40)
                lambda
        semicolon
      LC (5)
        if
        oppar
        Expresion (38)
          Expresion1 (41)
            Expresion2 (44)
              Expresion3 (53)
                id
              Expresion2Aux (46)
                lambda
            Expresion1Aux (42)
              minorthan
              Expresion1 (41)
                Expresion2 (44)
                  Expresion3 (48)
                    intconst
                  Expresion2Aux (46)
                    lambda
                Expresion1Aux (43)
                  lambda
          ExpresionAux (40)
            lambda
        clpar
        CuerpoIf (9)
          LC (4)
            LS (24)
              return
              ExpReturn (36)
                Expresion (38)
                  Expresion1 (41)
                    Expresion2 (44)
                      Expresion3 (53)
                        id
                      Expresion2Aux (46)
                        lambda
                    Expresion1Aux (43)
                      lambda
                  ExpresionAux (40)
                    lambda
            semicolon
      Cuerpo (11)
        lambda
    clbra
  S (1)
    LC (4)
      LS (20)
        let
        Tipo (30)
          int
        id
        Asignar (34)
          eq
          Expresion (38)
            Expresion1 (41)
              Expresion2 (44)
                Expresion3 (48)
                  intconst
                Expresion2Aux (46)
                  lambda
              Expresion1Aux (43)
                lambda
            ExpresionAux (40)
              lambda
      semicolon
    S (1)
      LC (4)
        LS (23)
          write
          Expresion (38)
            Expresion1 (41)
              Expresion2 (44)
                Expresion3 (47)
                  oppar
                  Expresion (38)
                    Expresion1 (41)
                      Expresion2 (44)
                        Expresion3 (50)
                          string
                        Expresion2Aux (46)
                          lambda
                      Expresion1Aux (43)
                        lambda
                    ExpresionAux (40)
                      lambda
                  clpar
                Expresion2Aux (46)
                  lambda
              Expresion1Aux (43)
                lambda
            ExpresionAux (40)
              lambda
        semicolon
      S (3)
        eof
  eof
\end{verbatim}
\end{itemize}

\subsubsection{Caso Correcto}
\begin{itemize}[label={-}, itemsep=-1em, topsep=0.5em, parsep=-0.2em]
    \item \textbf{Código:}\begin{verbatim} 
let boolean check;
check = 10 < 30;

function void print(string mostrar){
    write mostrar;
}

if(check)
    write('Diez es menor que 30');
else
    print('Diez es mayor que 30');
    \end{verbatim}
    \item \textbf{Volcado Parse:}\\
Descendente 1 4 20 33 35 1 4 21 26 38 41 44 48 46 42 41 44 48 46 43 40 2 7 28 12 32 19 10 4 23 38 41 44 53 55 46 43 40 11 1 5 38 41 44 53 55 46 43 40 9 4 23 38 41 44 47 38 41 44 50 46 43 40 46 43 40 1 6 9 4 21 25 14 38 41 44 50 46 43 40 17 3 
\\\\
    \item \textbf{Árbol Sintáctico:}
\begin{verbatim}
S (1)
  LC (4)
    LS (20)
      let
      Tipo (33)
        boolean
      id
      Asignar (35)
        lambda
    semicolon
  S (1)
    LC (4)
      LS (21)
        id
        IdOpt (26)
          eq
          Expresion (38)
            Expresion1 (41)
              Expresion2 (44)
                Expresion3 (48)
                  intconst
                Expresion2Aux (46)
                  lambda
              Expresion1Aux (42)
                minorthan
                Expresion1 (41)
                  Expresion2 (44)
                    Expresion3 (48)
                      intconst
                    Expresion2Aux (46)
                      lambda
                  Expresion1Aux (43)
                    lambda
              ExpresionAux (40)
                lambda
        semicolon
    S (2)
      LF (7)
        function
        TypeFun (28)
          void
        id
        oppar
        Args (12)
          Tipo (32)
            string
          id
          ArgMore (19)
            lambda
        clpar
        opbra
        Cuerpo (10)
          LC (4)
            LS (23)
              write
              Expresion (38)
                Expresion1 (41)
                  Expresion2 (44)
                    Expresion3 (53)
                      id
                    Expresion4 (55)
                      lambda
                  Expresion2Aux (46)
                    lambda
                Expresion1Aux (43)
                  lambda
              ExpresionAux (40)
                lambda
            semicolon
          Cuerpo (11)
            lambda
        clbra
      S (1)
        LC (5)
          if
          oppar
          Expresion (38)
            Expresion1 (41)
              Expresion2 (44)
                Expresion3 (53)
                  id
                Expresion4 (55)
                  lambda
              Expresion2Aux (46)
                lambda
            Expresion1Aux (43)
              lambda
          ExpresionAux (40)
            lambda
          clpar
          CuerpoIf (9)
            LC (4)
              LS (23)
                write
                Expresion (38)
                  Expresion1 (41)
                    Expresion2 (44)
                      Expresion3 (47)
                        oppar
                        Expresion (38)
                          Expresion1 (41)
                            Expresion2 (44)
                              Expresion3 (50)
                                string
                              Expresion2Aux (46)
                                lambda
                            Expresion1Aux (43)
                              lambda
                          ExpresionAux (40)
                            lambda
                        clpar
                      Expresion2Aux (46)
                        lambda
                  Expresion1Aux (43)
                    lambda
                ExpresionAux (40)
                  lambda
              semicolon
        S (1)
          LC (6)
            else
            CuerpoIf (9)
              LC (4)
                LS (21)
                  id
                  IdOpt (25)
                    oppar
                    ArgsLlamada (14)
                      Expresion (38)
                        Expresion1 (41)
                          Expresion2 (44)
                            Expresion3 (50)
                              string
                            Expresion2Aux (46)
                              lambda
                          Expresion1Aux (43)
                            lambda
                        ExpresionAux (40)
                          lambda
                      ArgMoreLlamada (17)
                        lambda
                    clpar
                semicolon
          S (3)
            eof
\end{verbatim}
\end{itemize}

\subsubsection{Caso Correcto}
\begin{itemize}[label={-}, itemsep=-1em, topsep=0.5em, parsep=-0.2em]
    \item \textbf{Código:}\begin{verbatim} 
function boolean comparar(int num1, int num2){
    return num1 < num2;
}

write('Mostrando comparación...');
write(comparar(3+(27+32+54), 2+2+2+2+(3+4)+74));

let string input;
read input;
write input;
    \end{verbatim}
    \item \textbf{Volcado Parse:}\\
        Descendente: 2 7 29 33 12 30 18 30 19 10 4 24 36 38 41 44 53 55 46 42 41 44 53 55 46 43 40 11 1 4 23 38 41 44 47 38 41 44 50 46 43 40 46 43 40 1 4 23 38 41 44 47 38 41 44 53 54 14 38 41 44 48 45 44 47 38 41 44 48 45 44 48 45 44 48 46 43 40 46 43 40 16 38 41 44 48 45 44 48 45 44 48 45 44 48 45 44 47 38 41 44 48 45 44 48 46 43 40 45 44 48 46 43 40 17 46 43 40 46 43 40 1 4 20 32 35 1 4 22 1 4 23 38 41 44 53 55 46 43 40 3 
\\\\
    \item \textbf{Árbol Sintáctico:}
\begin{verbatim}
S (2)
  LF (7)
    function
    TypeFun (29)
      Tipo (33)
        boolean
    id
    oppar
    Args (12)
      Tipo (30)
        int
      id
      ArgMore (18)
        comma
        Tipo (30)
          int
        id
        ArgMore (19)
          lambda
    clpar
    opbra
    Cuerpo (10)
      LC (4)
        LS (24)
          return
          ExpReturn (36)
            Expresion (38)
              Expresion1 (41)
                Expresion2 (44)
                  Expresion3 (53)
                    id
                  Expresion4 (55)
                    lambda
                Expresion2Aux (46)
                  lambda
              Expresion1Aux (42)
                minorthan
                Expresion1 (41)
                  Expresion2 (44)
                    Expresion3 (53)
                      id
                    Expresion4 (55)
                      lambda
                  Expresion2Aux (46)
                    lambda
                Expresion1Aux (43)
                  lambda
            ExpresionAux (40)
              lambda
        semicolon
      Cuerpo (11)
        lambda
    clbra
  S (1)
    LC (4)
      LS (23)
        write
        Expresion (38)
          Expresion1 (41)
            Expresion2 (44)
              Expresion3 (47)
                oppar
                Expresion (38)
                  Expresion1 (41)
                    Expresion2 (44)
                      Expresion3 (50)
                        string
                      Expresion2Aux (46)
                        lambda
                    Expresion1Aux (43)
                      lambda
                  ExpresionAux (40)
                    lambda
                clpar
              Expresion2Aux (46)
                lambda
            Expresion1Aux (43)
              lambda
          ExpresionAux (40)
            lambda
      semicolon
    S (1)
      LC (4)
        LS (23)
          write
          Expresion (38)
            Expresion1 (41)
              Expresion2 (44)
                Expresion3 (47)
                  oppar
                  Expresion (38)
                    Expresion1 (41)
                      Expresion2 (44)
                        Expresion3 (53)
                          id
                        Expresion4 (54)
                          oppar
                          ArgsLlamada (14)
                            Expresion (38)
                              Expresion1 (41)
                                Expresion2 (44)
                                  Expresion3 (48)
                                    intconst
                                  Expresion2Aux (45)
                                    sum
                                    Expresion2 (44)
                                      Expresion3 (47)
                                        oppar
                                        Expresion (38)
                                          Expresion1 (41)
                                            Expresion2 (44)
                                              Expresion3 (48)
                                                intconst
                                              Expresion2Aux (45)
                                                sum
                                                Expresion2 (44)
                                                  Expresion3 (48)
                                                    intconst
                                                  Expresion2Aux (45)
                                                    sum
                                                    Expresion2 (44)
                                                      Expresion3 (48)
                                                        intconst
                                                      Expresion2Aux (46)
                                                        lambda
                                                    Expresion1Aux (43)
                                                      lambda
                                                  ExpresionAux (40)
                                                    lambda
                                                clpar
                                              Expresion2Aux (46)
                                                lambda
                                          Expresion1Aux (43)
                                            lambda
                                        ExpresionAux (40)
                                          lambda
                                      clpar
                                    Expresion2Aux (46)
                                      lambda
                                Expresion1Aux (43)
                                  lambda
                            ExpresionAux (40)
                              lambda
                            ArgMoreLlamada (16)
                              comma
                              Expresion (38)
                                Expresion1 (41)
                                  Expresion2 (44)
                                    Expresion3 (48)
                                      intconst
                                    Expresion2Aux (45)
                                      sum
                                      Expresion2 (44)
                                        Expresion3 (48)
                                          intconst
                                        Expresion2Aux (45)
                                          sum
                                          Expresion2 (44)
                                            Expresion3 (48)
                                              intconst
                                            Expresion2Aux (45)
                                              sum
                                              Expresion2 (44)
                                                Expresion3 (48)
                                                  intconst
                                                Expresion2Aux (45)
                                                  sum
                                                  Expresion2 (44)
                                                    Expresion3 (47)
                                                      oppar
                                                      Expresion (38)
                                                        Expresion1 (41)
                                                          Expresion2 (44)
                                                            Expresion3 (48)
                                                              intconst
                                                            Expresion2Aux (45)
                                                              sum
                                                              Expresion2 (44)
                                                                Expresion3 (48)
                                                                  intconst
                                                                Expresion2Aux (46)
                                                                  lambda
                                                            Expresion1Aux (43)
                                                              lambda
                                                          ExpresionAux (40)
                                                            lambda
                                                        clpar
                                                      Expresion2Aux (45)
                                                        sum
                                                        Expresion2 (44)
                                                          Expresion3 (48)
                                                            intconst
                                                          Expresion2Aux (46)
                                                            lambda
                                                        Expresion1Aux (43)
                                                          lambda
                                                      ExpresionAux (40)
                                                        lambda
                                                Expresion1Aux (43)
                                                  lambda
                                              ExpresionAux (40)
                                                lambda
                                          Expresion1Aux (43)
                                            lambda
                                        ExpresionAux (40)
                                          lambda
                                    Expresion1Aux (43)
                                      lambda
                                ExpresionAux (40)
                                  lambda
                            ArgMoreLlamada (17)
                              lambda
                          clpar
                      Expresion2Aux (46)
                        lambda
                    Expresion1Aux (43)
                      lambda
                  ExpresionAux (40)
                    lambda
                clpar
              Expresion2Aux (46)
                lambda
            Expresion1Aux (43)
              lambda
          ExpresionAux (40)
            lambda
        semicolon
      S (1)
        LC (4)
          LS (20)
            let
            Tipo (32)
              string
            id
            Asignar (35)
              lambda
          semicolon
        S (1)
          LC (4)
            LS (22)
              read
              id
            semicolon
          S (1)
            LC (4)
              LS (23)
                write
                Expresion (38)
                  Expresion1 (41)
                    Expresion2 (44)
                      Expresion3 (53)
                        id
                      Expresion4 (55)
                        lambda
                    Expresion2Aux (46)
                      lambda
                  Expresion1Aux (43)
                    lambda
              ExpresionAux (40)
                lambda
              semicolon
            S (3)
              eof
\end{verbatim}
\end{itemize}

\newpage
\subsection{Casos Erróneos}

\subsubsection{Caso Erróneo}
\begin{itemize}[label={-}, itemsep=-1em, topsep=0.5em, parsep=-0.2em]
    \item \textbf{Código:}\begin{verbatim} 
function int mulPorCuatro(int num){
    return num+num+num+num;
}

let num1;
write 'Introduce el número a multiplicar por cuatro';
read num1;
write(mulPorCuatro(num1));
    \end{verbatim}
    \item \textbf{Error generado:}\\
        ¡Error sintáctico! No hay producción para [Tipo, id], se esperaba un tipo en la línea 5.
\\\\
\end{itemize}


\subsubsection{Caso Erróneo}
\begin{itemize}[label={-}, itemsep=-1em, topsep=0.5em, parsep=-0.2em]
    \item \textbf{Código:}\begin{verbatim} 
let string saludo = 'Buenas! Qué tal?'

write saludo;
write ('responde al saludo:');
let string respuesta;
read respuesta;
write respuesta;
    \end{verbatim}
    \item \textbf{Error generado:}\\
    ¡Error sintáctico! No hay producción para [Expresion2Aux, write], sentencia mal terminada cerca de la línea 3.
\\\\
\end{itemize}

\subsubsection{Caso Erróneo}
\begin{itemize}[label={-}, itemsep=-1em, topsep=0.5em, parsep=-0.2em]
    \item \textbf{Código:}\begin{verbatim} 
function void muestraSuma(num1, num2){
    return write(num1 + num2);
}

let boolean cond = true;
let numero1 = 10;
let numero2 = 20;
if(true)
    numero1 += numero2;
    \end{verbatim}
    \item \textbf{Error generado:}\\
¡Error sintáctico! No hay producción para [Args, id], función mal declarada en línea 1. 
\\\\
\end{itemize}

\begin{landscape}
    \thispagestyle{empty}
    \subsection*{\centering Tabla LL1}
    \vfill
    \begin{table}[h!]
        \centering
        \noindent\hspace*{-0.065\textwidth}
        \resizebox{1.5\textwidth}{0.25\textheight}{%
            \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|} \hline
                               & function                             & return           & write           & read      & if                     & else          & true                     & false                    & let                 & id                       & void & int             & float           & string                   & boolean         & intconst                 & realconst                & pluseq       & eq          & comma                      & semicolon               & oppar                    & clpar  & opbra      & clbra  & sum            & and           & $<$            & eof \\ \hline
                S              & LC S                                 & LC S             & LC S            & LC S      & LC S                   &               &                          &                          & LC S                & LC S                     &      &                 &                 &                          &                 &                          &                          &              &             &                            &                         &                          &        &            &        &                &               &                      & eof \\ \hline
                LC             &                                      & LS ;             & LS ;            & LS ;      & if(EX) CI & else CI &                          &                          & LS ;                & LS ;                     &      &                 &                 &                          &                 &                          &                          &              &             &                            &                         &                          &        &            &        &                &               &                      &     \\ \hline
                LF             & function TF id (AR)\{CU\} &                  &                 &           &                        &               &                          &                          &                     &                          &      &                 &                 &                          &                 &                          &                          &              &             &                            &                         &                          &        &            &        &                &               &                      &     \\ \hline
                CI       &                                      & LC               & LC              & LC        & LC                     & LC            &                          &                          & LC                  & LC                       &      &                 &                 &                          &                 &                          &                          &              &             &                            &                         &                          &        & \{CU\} &        &                &               &                      &     \\ \hline
                CU         &                                      & LC CU        & LC CU       & LC CU & LC CU              & LC CU     &                          &                          & LC CU           & LC CU                &      &                 &                 &                          &                 &                          &                          &              &             &                            &                         &                          &        &            & $\lambda$ &                &               &                      &     \\ \hline
                AR           &                                      &                  &                 &           &                        &               &                          &                          &                     &                          &      & TI id AM & TI id AM & TI id AM          & TI id AM &                          &                          &              &             &                            &                         &                          &        &            &        &                &               &                      &     \\ \hline
                AL    &                                      &                  &                 &           &                        &               & EX AML & EX AML &                     & EX AML &      &                 &                 & EX AML &                 & EX AML & EX AML &              &             &                            &                         & EX AML & $\lambda$ &            &        &                &               &                      &     \\ \hline
                AML &                                      &                  &                 &           &                        &               &                          &                          &                     &                          &      &                 &                 &                          &                 &                          &                          &              &             & , EX AML &                         &                          & $\lambda$ &            &        &                &               &                      &     \\ \hline
                AM        &                                      &                  &                 &           &                        &               &                          &                          &                     &                          &      &                 &                 &                          &                 &                          &                          &              &             & , TIpo id AM          &                         &                          & $\lambda$ &            &        &                &               &                      &     \\ \hline
                LS             &                                      & return ER & write EX & read id   &                        &               &                          &                          & let TI id AS & id IO                 &      &                 &                 &                          &                 &                          &                          &              &             &                            &                         &                          &        &            &        &                &               &                      &     \\ \hline
                IO          &                                      &                  &                 &           &                        &               &                          &                          &                     &                          &      &                 &                 &                          &                 &                          &                          & += EX & = EX &                            &                         & (AL)            &        &            &        &                &               &                      &     \\ \hline
                TF        &                                      &                  &                 &           &                        &               &                          &                          &                     &                          & void & TI            & TI            & TI                     & TI            &                          &                          &              &             &                            &                         &                          &        &            &        &                &               &                      &     \\ \hline
                TI           &                                      &                  &                 &           &                        &               &                          &                          &                     &                          &      & int             & float           & string                   & boolean         &                          &                          &              &             &                            &                         &                          &        &            &        &                &               &                      &     \\ \hline
                AS        &                                      &                  &                 &           &                        &               &                          &                          &                     &                          &      &                 &                 &                          &                 &                          &                          &              & = EX &                            & $\lambda$                  &                          &        &            &        &                &               &                      &     \\ \hline
                ER      &                                      &                  &                 &           &                        &               & EX                & EX                &                     & EX                &      &                 &                 & EX                &                 & EX                & EX                &              &             &                            & $\lambda$                  & EX                &        &            &        &                &               &                      &     \\ \hline
                EX      &                                      &                  &                 &           &                        &               & E1 EA  & E1 EA  &                     &                          &      &                 &                 & E1 EA  &                 & E1 EA  & E1 EA  &              &             &                            & E1 EA & E1 EA  &        &            &        &                &               &                      &     \\ \hline
                EA   &                                      &                  &                 &           &                        &               &                          &                          &                     &                          &      &                 &                 &                          &                 &                          &                          &              &             & $\lambda$                     & $\lambda$                  &                          & $\lambda$ &            &        &                & and EX &                      &     \\ \hline
                E1     &                                      &                  &                 &           &                        &               & E2 E1A & E2 E1A &                     & E2 E1A &      &                 &                 & E2 E1A &                 & E2 E1A & E2 E1A &              &             &                            &                         & E2 E1A &        &            &        &                &               &                      &     \\ \hline
                E1A  &                                      &                  &                 &           &                        &               &                          &                          &                     &                          &      &                 &                 &                          &                 &                          &                          &              &             & $\lambda$                     & $\lambda$                  &                          & $\lambda$ &            &        &                & $\lambda$        & $<$ E1 &     \\ \hline
                E2     &                                      &                  &                 &           &                        &               & E3 E2A & E3 E2A &                     & E3 E2A &      &                 &                 & E3 E2A &                 & E3 E2A & E3 E2A &              &             &                            &                         & E3 E2A &        &            &        &                &               &                      &     \\ \hline
                E2A  &                                      &                  &                 &           &                        &               &                          &                          &                     &                          &      &                 &                 &                          &                 &                          &                          &              &             & $\lambda$                     & $\lambda$                  &                          & $\lambda$ &            &        & sum E2 & $\lambda$        & $\lambda$               &     \\ \hline
                E3     &                                      &                  &                 &           &                        &               & true                     & false                    &                     & id E4            &      &                 &                 & string                   &                 & intconst                 & realconst                &              &             &                            &                         & (EX)              &        &            &        &                &               &                      &     \\ \hline
                E4     &                                      &                  &                 &           &                        &               &                          &                          &                     &                          &      &                 &                 &                          &                 &                          &                          &              &             & $\lambda$                     & $\lambda$                  & (AL)            & $\lambda$ &            &        & $\lambda$         & $\lambda$        & $\lambda$               &     \\ \hline
            \end{tabular}%
            \label{sec:tabla}
            }
    \end{table}
    \vfill
\end{landscape}

\begin{figure}[h!]
\centering
\includegraphics[width=0.45\textwidth]{../figures/goose.png} 
\caption{Barnacla canadiense intencional.}
\end{figure}

\end{document}
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
