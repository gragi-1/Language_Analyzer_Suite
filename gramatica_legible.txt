Terminales = { boolean else float function if int let read return string void write floatconst intconst str id += = , ; ( ) { } + && < boolconst eof }

## No Terminales para funcionalidad, aparte existe lambda ##

NoTerminales = { S AF A Definir Tipo Igualar Descriptor Entero IntRecur TermInt TermInt2 Real FlRecur TermFl TermFl2 Booleano BoolRecur TermBool Cadena LlamarFuncion ArgPre ArgRec WriteAlt Cond ARec CondEl ElseAux DefFuncion Arg ArgAux AFuncion AFuncionVoid DefFuncionAux DescripFun Num }


Axioma = S

Producciones = {
    S -> AF eof

    AF -> A AF
    AF -> DefFuncion AF                 				// Separado para no poder definir funciones dentro de otras funciones o condicionales
    AF -> lambda

    A -> Definir id Igualar ;
    A -> id += Num ;
    A -> LlamarFuncion ;
    A -> read id ;
    A -> write WriteAlt ;
    A -> if ( Booleano ) Cond

    Definir -> let Tipo                 				// Definir no se anula solo en el caso de definir una variable
    Definir -> lambda

    Num -> Entero
    Num -> Real

    Tipo -> int
    Tipo -> float
    Tipo -> string
    Tipo -> boolean

    Igualar -> = Descriptor
    Igualar -> lambda

    Descriptor -> Num                   				// Para no duplicar entre enteros y reales
    Descriptor -> Booleano
    Descriptor -> Cadena

    Entero -> TermInt IntRecur

    IntRecur -> + TermInt2 IntRecur     				// Para poder sumar en la misma línea
    IntRecur -> lambda

    TermInt -> id
    TermInt -> intconst
    TermInt -> LlamarFuncion + TermInt2

    TermInt2 -> id
    TermInt2 -> intconst
    TermInt2 -> LlamarFuncion

    Real -> TermFl FlRecur              				// Igual que para los enteros

    FlRecur -> + TermFl2 FlRecur
    FlRecur -> lambda

    TermFl -> id
    TermFl -> floatconst
    TermFl -> LlamarFuncion + TermFl2

    TermFl2 -> id
    TermFl2 -> floatconst
    TermFl2 -> LlamarFuncion

    Booleano -> TermBool BoolRecur

    BoolRecur -> && TermBool BoolRecur
    BoolRecur -> lambda

    TermBool -> id
    TermBool -> boolconst
    TermBool -> Entero < Entero         				// Para comparar operaciones de enteros y reales
    TermBool -> Real < Real
    TermBool -> LlamarFuncion

    Cadena -> id
    Cadena -> str

    LlamarFuncion -> id ( ArgPre )

    ArgPre -> Descriptor ArgRec         				// Para asegurarse que solo haya una opción de ningún argumento
    ArgPre -> lambda

    ArgRec -> , Descriptor ArgRec
    ArgRec -> lambda

    WriteAlt -> Descriptor
    WriteAlt -> ( Descriptor ArgRec )

    Cond -> A CondEl                    				// Condicional simple
    Cond -> ; CondEl                    				// Para poder dejarlo vacío
    Cond -> { ARec } CondEl             				// Condicional complejo, se pone una A para asegurar al menos un argumento

    ARec -> A ARec
    ARec -> lambda

    CondEl -> else ElseAux              				// Para poder poner else en los ifs
    CondEl -> lambda

    ElseAux -> A                        				// Else simple
    ElseAux -> ;                        				// Para poder dejarlo vacío
    ElseAux -> { ARec }                 				// Else complejo

    DefFuncion -> function DefFuncionAux }

    DefFuncionAux -> Tipo DescripFun AFuncion
    DefFuncionAux -> void DescripFun AFuncionVoid

    DescripFun -> id ( Arg ) {

    Arg -> Tipo id ArgAux
    Arg -> lambda

    ArgAux -> , Tipo id ArgAux          				// Se hace un auxiliar exclusivamente por la coma
    ArgAux -> lambda

    AFuncion -> A AFuncion 
    AFuncion -> return Descriptor ;     				// No se ha implementado el caso de los return dentro de condicionales

    AFuncionVoid -> A AFuncionVoid
    AFuncionVoid -> return ;            				// Para poder poner un return vacío
    AFuncionVoid -> lambda
}
