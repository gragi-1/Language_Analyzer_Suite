Terminales = { function return write read if else true false let id void int float string boolean intconst realconst str pluseq eq comma semicolon oppar clpar opbra clbra sum and minorthan eof }

NoTerminales = { S LC LF LE CuerpoIf Cuerpo Args ArgsLlamada ArgMore ArgMoreLlamada LS IdOpt TypeFun Tipo Asignar ExpReturn Expresion ExpresionAux Expresion1 Expresion1Aux Expresion2 Expresion2Aux Expresion3 Expresion4 }

Axioma = S

Producciones = {
S -> LC S 
S -> LF S
S -> eof

LC -> LS semicolon
LC -> if oppar Expresion clpar CuerpoIf LE

LE -> else CuerpoIf
LE -> lambda

LF -> function TypeFun id oppar Args clpar opbra Cuerpo clbra

CuerpoIf -> opbra Cuerpo clbra
CuerpoIf -> LC

Cuerpo -> LC Cuerpo
Cuerpo -> lambda

Args -> Tipo id ArgMore
Args -> void

ArgsLlamada -> Expresion ArgMoreLlamada
ArgsLlamada -> lambda

ArgMoreLlamada -> comma Expresion ArgMoreLlamada
ArgMoreLlamada -> lambda

ArgMore -> comma Tipo id ArgMore
ArgMore -> lambda

LS -> let Tipo id Asignar
LS -> id IdOpt
LS -> read id
LS -> write Expresion
LS -> return ExpReturn

IdOpt -> oppar ArgsLlamada clpar
IdOpt -> eq Expresion
IdOpt -> pluseq Expresion

TypeFun -> void
TypeFun -> Tipo

Tipo -> int
Tipo -> float
Tipo -> string
Tipo -> boolean

Asignar -> eq Expresion
Asignar -> lambda

ExpReturn -> Expresion
ExpReturn -> lambda

Expresion -> Expresion1 ExpresionAux

ExpresionAux -> and Expresion
ExpresionAux -> lambda

Expresion1 -> Expresion2 Expresion1Aux {Expresion1.tipo := if Expresion1Aux.tipo = void then Expresion2.tipo
                                        else if Expresion1Aux.tipo = Expresion2.tipo then Expresion2.tipo
                                        else tipo_error}

Expresion1Aux -> minorthan Expresion1 {Expresion1Aux.tipo := if Expresion1.tipo = int then int
                                       else if Expresion1.tipo = float then float
                                       else tipo_error}
Expresion1Aux -> lambda {Expresion1Aux.tipo := void}

Expresion2 -> Expresion3 Expresion2Aux {Expresion2.tipo := if Expresion2Aux.tipo = void then Expresion3.tipo
                                                                                else if Expresion2Aux.tipo = Expresion3.tipo then Expresion3.tipo
                                                                                else tipo_error}

Expresion2Aux -> sum Expresion2 {Expresion2Aux.tipo := if Expresion2.tipo = int then int
                                 else if Expresion2.tipo = float then float
                                 else tipo_error}
Expresion2Aux -> lambda {Expresion2Aux.tipo := void}

Expresion3 -> oppar Expresion clpar {Expresion3.tipo := Expresion.tipo}
Expresion3 -> intconst {Expresion3.tipo := int}
Expresion3 -> realconst {Expresion3.tipo := float}
Expresion3 -> str {Expresion3.tipo := string}
Expresion3 -> true {Expresion3.tipo := boolean}
Expresion3 -> false {Expresion3.tipo := boolean}
Expresion3 -> id Expresion4 {Expresion3.tipo := if Expresion4.tipo = void then BuscaTipoTS(id)
                             else if }

Expresion4 -> oppar ArgsLlamada clpar {Expresion4.tipo := ArgsLlamada.tipo}
Expresion4 -> lambda {Expresion4.tipo := void}
}
