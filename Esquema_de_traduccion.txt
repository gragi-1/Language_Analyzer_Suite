Terminales = { function return write read if else true false let id void int float string boolean intconst realconst str pluseq eq comma semicolon oppar clpar opbra clbra sum and minorthan eof }

NoTerminales = { S LC LF LE CuerpoIf Cuerpo Args ArgsLlamada ArgMore ArgMoreLlamada LS IdOpt TypeFun Tipo Asignar ExpReturn Expresion ExpresionAux Expresion1 Expresion1Aux Expresion2 Expresion2Aux Expresion3 Expresion4 }

Axioma = S

Producciones = {
S -> LC S 
S -> LF S
S -> eof

LC -> LS semicolon
LC -> if oppar Expresion clpar CuerpoIf LE

LE -> else CuerpoIf
LE -> lambda

LF -> function TypeFun id oppar Args clpar opbra Cuerpo clbra

CuerpoIf -> opbra Cuerpo clbra
CuerpoIf -> LC

Cuerpo -> LC Cuerpo
Cuerpo -> lambda

Args -> Tipo id ArgMore
Args -> void

ArgsLlamada -> Expresion ArgMoreLlamada
ArgsLlamada -> lambda

ArgMoreLlamada -> comma Expresion ArgMoreLlamada
ArgMoreLlamada -> lambda

ArgMore -> comma Tipo id ArgMore
ArgMore -> lambda

LS -> let Tipo id Asignar
LS -> id IdOpt
LS -> read id
LS -> write Expresion
LS -> return ExpReturn

IdOpt -> oppar ArgsLlamada clpar
IdOpt -> eq Expresion
IdOpt -> pluseq Expresion {IdOpt.tipo := if Expresion.tipo = int then int
						   else if Expresion.tipo = float then float
						   else tipo_error}

TypeFun -> void {TypeFun.tipo := void}
TypeFun -> Tipo {TypeFun.tipo := Tipo.tipo}

Tipo -> int {Tipo.tipo := int}
Tipo -> float {Tipo.tipo := float}
Tipo -> string {Tipo.tipo := string}
Tipo -> boolean {Tipo.tipo := boolean}

Asignar -> eq Expresion {Asignar.tipo := Expresion.tipo, Asignar.igualacion := tipo_error}
Asignar -> lambda {Asignar.tipo := void, Asignar.igualacion := tipo_ok}

ExpReturn -> Expresion {ExpReturn.tipo := Expresion.tipo}
ExpReturn -> lambda {ExpReturn.tipo := void}

Expresion -> Expresion1 ExpresionAux {Expresion.tipo := if ExpresionAux.tipo = void then Expresion1.tipo
									  else if ExpresionAux.tipo = Expresion1.tipo then boolean
									  else tipo_error}

ExpresionAux -> and Expresion {ExpresionAux.tipo := if Expresion.tipo = boolean then boolean
							   else tipo_error}
ExpresionAux -> lambda {ExpresionAux.tipo := void}

Expresion1 -> Expresion2 Expresion1Aux {Expresion1.tipo := if Expresion1Aux.tipo = void then Expresion2.tipo
										else if Expresion1Aux.tipo = Expresion2.tipo then Expresion2.tipo
										else tipo_error}

Expresion1Aux -> minorthan Expresion1 {Expresion1Aux.tipo := if Expresion1.tipo = int then int
									   else if Expresion1.tipo = float then float
									   else tipo_error}
Expresion1Aux -> lambda {Expresion1Aux.tipo := void}

Expresion2 -> Expresion3 Expresion2Aux {Expresion2.tipo := if Expresion2Aux.tipo = void then Expresion3.tipo
														   else if Expresion2Aux.tipo = Expresion3.tipo then Expresion3.tipo
														   else tipo_error}

Expresion2Aux -> sum Expresion2 {Expresion2Aux.tipo := if Expresion2.tipo = int then int
								 else if Expresion2.tipo = float then float
								 else tipo_error}
Expresion2Aux -> lambda {Expresion2Aux.tipo := void}

Expresion3 -> oppar Expresion clpar {Expresion3.tipo := Expresion.tipo}
Expresion3 -> intconst {Expresion3.tipo := int}
Expresion3 -> realconst {Expresion3.tipo := float}
Expresion3 -> str {Expresion3.tipo := string}
Expresion3 -> true {Expresion3.tipo := boolean}
Expresion3 -> false {Expresion3.tipo := boolean}
Expresion3 -> id Expresion4 {Expresion3.tipo := if BuscaTipoTS(id.pos) := Expresion4.tipo -> t then t
							 else if BuscaTipoTS(id.pos) := s -> t then tipo_error
							 else BuscaTipoTS(id.pos)}

Expresion4 -> oppar ArgsLlamada clpar {Expresion4.tipo := ArgsLlamada.tipo}
Expresion4 -> lambda {}
}
