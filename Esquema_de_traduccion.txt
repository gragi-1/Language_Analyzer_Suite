Terminales = { function return write read if else true false let id void int float string boolean intconst realconst str pluseq eq comma semicolon oppar clpar opbra clbra sum and minorthan eof }

NoTerminales = { S LC LF LE CuerpoIf Cuerpo Args ArgsLlamada ArgMore ArgMoreLlamada LS IdOpt TypeFun Tipo Asignar ExpReturn Expresion ExpresionAux Expresion1 Expresion1Aux Expresion2 Expresion2Aux Expresion3 Expresion4 }

Axioma = S

Producciones = {
S -> {if TSG = nulo then TSG := CrearTabla(), despG := 0} LC S {LiberarTabla(TSG)}
S -> {if TSG = nulo then TSG := CrearTabla(), despG := 0} LF S {LiberarTabla(TSG)}
S -> {if TSG = nulo then TSG := CrearTabla(), despG := 0} eof {LiberarTabla(TSG)}

LC -> LS semicolon {LC.tipo := if LS.tipo = tipo_error then tipo_error
							   else tipo_ok}
LC -> if oppar Expresion clpar CuerpoIf {LC.tipo := if Expresion.tipo = boolean then CuerpoIf.tipo
													else tipo_error}

LF -> function TypeFun id {TSL := CrearTabla(), despL := 0} oppar Args clpar {AñadeTipo(id.pos, Args.tipo -> TypeFun.tipo), AñadeEtiq(id.pos, NuevaEtiq())} opbra Cuerpo clbra {LiberarTabla(TSL)}

CuerpoIf -> opbra Cuerpo clbra LE {CuerpoIf.tipo := if Cuerpo.tipo = tipo_ok then LE.tipo
													else LE.tipo}
CuerpoIf -> LC {CuerpoIf.tipo := LC.tipo}

LE -> else opbra Cuerpo clbra {LE.tipo := Cuerpo.tipo}

LE -> lambda {LE.tipo := tipo_ok}

Cuerpo -> LC Cuerpo_1 {Cuerpo.tipo := if LC.tipo = tipo_ok then Cuerpo_1.tipo
									  else tipo_error}
Cuerpo -> lambda {Cuerpo.tipo := tipo_ok}

Args -> Tipo {AgregarTipo(id.pos, Tipo.tipo), AgregarDesplazamiento(id.pos, despL), despL := despL + Tipo.desp} id ArgMore {Args.tipo := Tipo.tipo x ArgMore.tipo}
Args -> void {}
Args -> lambda {}

ArgsLlamada -> Expresion ArgMoreLlamada {ArgsLlamada.tipo := if Expresion.tipo = tipo_error then tipo_error
																else if ArgMoreLlamada.tipo = tipo_error then tipo_error
																else Expresion.tipo x ArgMoreLlamada.tipo}
ArgsLlamada -> void {}
ArgsLlamada -> lambda {}

ArgMoreLlamada -> comma Expresion ArgMoreLlamada_1 {ArgMoreLlamada.tipo := if Expresion.tipo = tipo_error then tipo_error
																		   else if ArgMoreLlamada_1.tipo = tipo_error then tipo_error
																		   else Expresion.tipo x ArgMoreLlamada_1.tipo}
ArgMoreLlamada -> lambda {}

ArgMore -> comma Tipo {AgregarTipo(id.pos, Tipo.tipo), AgregarDesplazamiento(id.pos, despL), despL := despL + Tipo.desp} id ArgMore_1 {ArgMore.tipo := Tipo.tipo x ArgMore_1.tipo} // Solo para el EdT (ArgMore_1)
ArgMore -> lambda {}

LS -> let Tipo {AgregarTipo(id.pos, Tipo.tipo) if TSL = nulo then AgregarDesplazamiento(id.pos, despG), despG := despG + Tipo.desp
												else AgregarDesplazamiento(id.pos, despL), despL := despL + Tipo.desp} id Asignar {LS.tipo := if Asignar.igualacion = tipo_error then
																																				 if Asignar.tipo = Tipo.tipo then Tipo.tipo
																																				 else tipo_error
																																			  else Tipo.tipo}
LS -> id IdOpt {LS.tipo := if EstaEnTS(id.pos) = false then AgregarTipo(id.pos, int), AgregarDesplazamiento(id.pos, despG), despG := despG + 2
                            	if IdOpt.tipo = int then int
                                else if BuscaTipoTS(id.pos) = IdOpt.tipo then IdOpt.tipo
                                else if IdOpt.igualacion = tipo_ok then
                                    if BuscaTipoTS(id.pos) = IdOpt.tipo -> t then t
                                    else tipo_error
                                else tipo_error}
LS -> read id {LS.tipo := tipo_ok}
LS -> write Expresion {LS.tipo := if Expresion.tipo = int then tipo_ok
                       else if Expresion.tipo = float then tipo_ok
                       else if Expresion.tipo = string then tipo_ok
                       else tipo_error}
LS -> return ExpReturn {LS.tipo := ExpReturn.tipo}

IdOpt -> oppar ArgsLlamada clpar {IdOpt.tipo := ArgsLlamada.tipo, IdOpt.igualacion := tipo_ok}
IdOpt -> eq Expresion {IdOpt.tipo := Expresion.tipo, IdOpt.igualacion := tipo_error}
IdOpt -> pluseq Expresion {IdOpt.igualacion := tipo_ok, IdOpt.tipo := if Expresion.tipo = int then int
						   else if Expresion.tipo = float then float
						   else tipo_error}

TypeFun -> void {TypeFun.tipo := void}
TypeFun -> Tipo {TypeFun.tipo := Tipo.tipo}

Tipo -> int {Tipo.tipo := int, Tipo.desp := 1}
Tipo -> float {Tipo.tipo := float, Tipo.desp := 2}
Tipo -> string {Tipo.tipo := string, Tipo.desp := 64}
Tipo -> boolean {Tipo.tipo := boolean, Tipo.desp := 1}

Asignar -> eq Expresion {Asignar.tipo := Expresion.tipo, Asignar.igualacion := tipo_error}
Asignar -> lambda {Asignar.tipo := void, Asignar.igualacion := tipo_ok}

ExpReturn -> Expresion {ExpReturn.tipo := Expresion.tipo}
ExpReturn -> lambda {ExpReturn.tipo := void}

Expresion -> Expresion1 ExpresionAux {Expresion.tipo := if ExpresionAux.tipo = void then Expresion1.tipo
									  else if ExpresionAux.tipo = Expresion1.tipo then boolean
									  else tipo_error}

ExpresionAux -> and Expresion ExpresionAux1 {ExpresionAux.tipo := if Expresion.tipo = boolean then ExpresionAux1.tipo
							  				 else tipo_error}
ExpresionAux -> lambda {ExpresionAux.tipo := void}

Expresion1 -> Expresion2 Expresion1Aux {Expresion1.tipo := if Expresion1Aux.tipo = void then Expresion2.tipo
										else if Expresion1Aux.tipo = Expresion2.tipo then Expresion2.tipo
										else tipo_error}

Expresion1Aux -> minorthan Expresion2 Expresion1Aux1 {Expresion1Aux.tipo := if Expresion1Aux1.tipo = void then Expresion2.tipo
													  else if Expresion1Aux1.tipo = Expresion2.tipo then Expresion2.tipo
													  else tipo_error}
Expresion1Aux -> lambda {Expresion1Aux.tipo := void}

Expresion2 -> Expresion3 Expresion2Aux {Expresion2.tipo := if Expresion2Aux.tipo = void then Expresion3.tipo
														   else if Expresion2Aux.tipo = Expresion3.tipo then Expresion3.tipo
														   else tipo_error}

Expresion2Aux -> sum Expresion3 Expresion2Aux1 {Expresion2Aux.tipo := if Expresion2Aux1.tipo = void then Expresion3.tipo
																	  else if Expresion3.tipo = Expresion2Aux1.tipo then Expresion3.tipo
																	  else tipo_error}
Expresion2Aux -> lambda {Expresion2Aux.tipo := void}

Expresion3 -> oppar Expresion clpar {Expresion3.tipo := Expresion.tipo}
Expresion3 -> intconst {Expresion3.tipo := int}
Expresion3 -> realconst {Expresion3.tipo := float}
Expresion3 -> str {Expresion3.tipo := string}
Expresion3 -> true {Expresion3.tipo := boolean}
Expresion3 -> false {Expresion3.tipo := boolean}
Expresion3 -> id Expresion4 {Expresion3.tipo := if BuscaTipoTS(id.pos) := Expresion4.tipo -> t then t
							 else if BuscaTipoTS(id.pos) := s -> t then tipo_error
							 else BuscaTipoTS(id.pos)}

Expresion4 -> oppar ArgsLlamada clpar {Expresion4.tipo := ArgsLlamada.tipo}
Expresion4 -> lambda {}
}
