Terminales = { function return write read if else true false let id void int float string boolean intconst realconst str pluseq eq comma semicolon oppar clpar opbra clbra sum and minorthan eof }

NoTerminales = { S LC LF CuerpoIf Cuerpo Args ArgsLlamada ArgMore ArgMoreLlamada LS IdOpt TypeFun Tipo Asignar ExpReturn Expresion ExpresionAux Expresion1 Expresion1Aux Expresion2 Expresion2Aux Expresion3 Expresion4 }

Axioma = S

Producciones = {
S -> LC S 
S -> LF S
S -> eof

LC -> LS semicolon
LC -> if oppar Expresion clpar CuerpoIf 
LC -> else CuerpoIf

LF -> function TypeFun id oppar Args clpar opbra Cuerpo clbra

CuerpoIf -> opbra Cuerpo clbra
CuerpoIf -> LC

Cuerpo -> LC Cuerpo
Cuerpo -> lambda

Args -> Tipo id ArgMore
Args -> void

ArgsLlamada -> Expresion ArgMoreLlamada
ArgsLlamada -> lambda

ArgMoreLlamada -> comma Expresion ArgMoreLlamada
ArgMoreLlamada -> lambda

ArgMore -> comma Tipo id ArgMore
ArgMore -> lambda

LS -> let Tipo id Asignar
LS -> id IdOpt
LS -> read id
LS -> write Expresion
LS -> return ExpReturn

IdOpt -> oppar ArgsLlamada clpar
IdOpt -> eq Expresion
IdOpt -> pluseq Expresion

TypeFun -> void
TypeFun -> Tipo

Tipo -> int
Tipo -> float
Tipo -> string
Tipo -> boolean

Asignar -> eq Expresion
Asignar -> lambda

ExpReturn -> Expresion
ExpReturn -> lambda

Expresion -> Expresion1 ExpresionAux

ExpresionAux -> and Expresion
ExpresionAux -> lambda

Expresion1 -> Expresion2 Expresion1Aux

Expresion1Aux -> minorthan Expresion1
Expresion1Aux -> lambda

Expresion2 -> Expresion3 Expresion2Aux

Expresion2Aux -> sum Expresion2
Expresion2Aux -> lambda

Expresion3 -> oppar Expresion clpar
Expresion3 -> intconst
Expresion3 -> realconst
Expresion3 -> str
Expresion3 -> true
Expresion3 -> false
Expresion3 -> id Expresion4

Expresion4 -> oppar ArgsLlamada clpar
Expresion4 -> lambda
}
