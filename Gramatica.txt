Terminales = { boolean else float function if int let read return string void write true false id intconst realconst str pluseq eq comma semicolon oppar clpar opbra clbra sum and minorthan boolconst eof }

NoTerminales = { S LC LF CuerpoIf ElseOpt Cuerpo Args ArgMore LS IdOpt TypeFun Tipo Asignar ExpReturn ExpresiÃ³n ExpresionAux Expresion1 Expresion1Aux Expresion2 Expresion2Aux Expresion3 Expresion3 Expresion4 }

Axioma = S

Producciones = {
S -> LC S 
S -> LF S
S -> eof

LC -> LS semicolon
LC -> if oppar Expresion clpar CuerpoIf ElseOpt

LF -> function TypeFun id oppar Args clpar opbra Cuerpo clbra

CuerpoIf -> opbra Cuerpo clbra
CuerpoIf -> LS

ElseOpt -> else CuerpoIf
ElseOpt -> lambda

Cuerpo -> LC Cuerpo
Cuerpo -> lambda

Args -> Tipo id ArgMore
Args -> void

ArgMore -> comma Tipo id ArgMore
ArgMore -> lambda

LS -> let Tipo id Asignar
LS -> id IdOpt
LS -> read id
LS -> write Tipo
LS -> return ExpReturn

IdOpt -> oppar Args clpar
IdOpt -> eq Expresion
IdOpt -> pluseq Expresion

TypeFun -> void
TypeFun -> Tipo

Tipo -> int
Tipo -> float
Tipo -> str
Tipo -> boolean

Asignar -> eq Expresion
Asignar -> lambda

ExpReturn -> Expresion
ExpReturn -> lambda

Expresion -> Expresion1 ExpresionAux

ExpresionAux -> and Expresion
ExpresionAux -> lambda

Expresion1 -> Expresion2 Expresion1Aux

Expresion1Aux -> minorthan Expresion1
Expresion1Aux -> lambda

Expresion2 -> Expresion3 Expresion2Aux

Expresion2Aux -> sum Expresion2
Expresion2Aux -> lambda

Expresion3 -> oppar Expresion clpar
Expresion3 -> intconst
Expresion3 -> realconst
Expresion3 -> str
Expresion3 -> true
Expresion3 -> false
Expresion3 -> id Expresion4

Expresion4 -> oppar ArgList clpar
Expresion4 -> lambda
}
