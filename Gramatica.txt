Terminales = { boolean else float function if int let read return string void write floatconst intconst str idint idfl idbool idstr idfun pluseq eq comma semicolon oppar clpar opbra clbra sum and minorthan boolconst eof }
//// Terminales código de los tokens

//// No Terminales para funcionalidad, aparte existe lambda
NoTerminales = { S AF AB A Tipo Id Igualar IgualarPre Descriptor Entero IntRecur TermInt TermInt2 Real FlRecur TermFl TermFl2 Booleano BoolRecur TermBool Cadena LlamarFuncion ArgPre ArgRec WriteAlt Cond ARec CondEl ElseAux DefFuncion Arg ArgAux AFuncion AFuncionVoid DefFuncionAux DescripFun Num If2 Else2 AIfPre ElseAux2 AIf IfVoid ElseVoid AIfPreVoid ElseAuxVoid AIfVoid }

//// Axioma por defecto
Axioma = S

Producciones = {
S -> AF eof

AF -> AB AF
AF -> DefFuncion AF //// Separado para no poder definir funciones dentro de otras funciones o condicionales
AF -> lambda

AB -> A semicolon
AB -> if oppar Booleano clpar Cond

A -> let Tipo Id Igualar
A -> Id IgualarPre
A -> LlamarFuncion 
A -> read Id
A -> write WriteAlt

Num -> Entero
Num -> Real

Tipo -> int
Tipo -> float
Tipo -> string
Tipo -> boolean

Id -> idint
Id -> idfl
Id -> idbool
Id -> idstr

IgualarPre -> Igualar
IgualarPre -> pluseq Num

Igualar -> eq Descriptor
Igualar -> lambda

Descriptor -> Num //// Para no duplicar entre enteros y reales
Descriptor -> Booleano
Descriptor -> Cadena

Entero -> TermInt IntRecur

IntRecur -> sum TermInt2 IntRecur //// Para poder sumar en la misma línea
IntRecur -> lambda

TermInt -> idint
TermInt -> intconst
TermInt -> LlamarFuncion sum TermInt2

TermInt2 -> idint
TermInt2 -> intconst
TermInt2 -> LlamarFuncion

Real -> TermFl FlRecur //// Igual que para los enteros

FlRecur -> sum TermFl2 FlRecur
FlRecur -> lambda

TermFl -> idfl
TermFl -> floatconst
TermFl -> LlamarFuncion sum TermFl2

TermFl2 -> idfl
TermFl2 -> floatconst
TermFl2 -> LlamarFuncion

Booleano -> TermBool BoolRecur

BoolRecur -> and TermBool BoolRecur
BoolRecur -> lambda

TermBool -> idbool
TermBool -> boolconst
TermBool -> Entero minorthan Entero //// Para comparar operaciones de enteros y reales
TermBool -> Real minorthan Real
TermBool -> LlamarFuncion //// Para conseguir poder llamar exclusivamente a una función

Cadena -> idstr
Cadena -> str

LlamarFuncion -> idfun oppar ArgPre clpar

ArgPre -> Descriptor ArgRec //// Para asegurarse que solo haya una opción de ningún argumento
ArgPre -> lambda

ArgRec -> comma Descriptor ArgRec
ArgRec -> lambda

WriteAlt -> Descriptor
WriteAlt -> oppar Descriptor ArgRec clpar

Cond -> AB CondEl //// Condicional simple
Cond -> semicolon CondEl //// Para poder dejarlo vacío
Cond -> opbra ARec clbra CondEl //// Condicional complejo, se pone una A para asegurar al menos un argumento

ARec -> AB ARec
ARec -> lambda

CondEl -> else ElseAux //// Para poder poner else en los ifs
CondEl -> lambda

ElseAux -> AB //// Else simple
ElseAux -> semicolon //// Para poder dejarlo vacío
ElseAux -> opbra ARec clbra //// Else complejo

DefFuncion -> function DefFuncionAux clbra

DefFuncionAux -> Tipo DescripFun AFuncion
DefFuncionAux -> void DescripFun AFuncionVoid

DescripFun -> idfun oppar Arg clpar opbra

Arg -> Tipo Id ArgAux
Arg -> lambda

ArgAux -> comma Tipo Id ArgAux //// Se hace un auxiliar exclusivamente por la coma
ArgAux -> lambda

AFuncion -> A semicolon AFuncion
AFuncion -> if oppar Booleano clpar If2
AFuncion -> return Descriptor semicolon //// No se ha implementado el caso de los return dentro de condicionales

AFuncionVoid -> A AFuncionVoid
AFuncionVoid -> if oppar Booleano clpar IfVoid
AFuncionVoid -> return semicolon //// Para poder poner un return vacío
AFuncionVoid -> lambda

If2 -> AIfPre Else2 //// Condicional simple
If2 -> opbra AIf clbra Else2 //// Condicional complejo, se pone una A para asegurar al menos un argumento

Else2 -> else ElseAux2 //// Para poder poner else en los ifs
Else2 -> lambda

AIfPre -> A semicolon AIf
AIfPre -> If2 AIf
AIfPre -> semicolon

AIf -> A semicolon AIf
AIf -> return Descriptor semicolon
AIf -> If2 AIf
AIf -> lambda

ElseAux2 -> AIfPre //// Else simple
ElseAux2 -> opbra AIfPre clbra //// Else complejo

IfVoid -> AIfPreVoid ElseVoid //// Condicional simple
IfVoid -> opbra AIfVoid clbra ElseVoid //// Condicional complejo, se pone una A para asegurar al menos un argumento

ElseVoid -> else ElseAuxVoid //// Para poder poner else en los ifs
ElseVoid -> lambda

AIfPreVoid -> A semicolon AIfVoid
AIfPreVoid -> IfVoid AIfVoid
AIfPreVoid -> semicolon

AIfVoid -> A semicolon AIfVoid
AIfVoid -> return semicolon
AIfVoid -> IfVoid AIfVoid
AIfVoid -> lambda

ElseAuxVoid -> AIfPreVoid //// Else simple
ElseAuxVoid -> opbra AIfPreVoid clbra //// Else complejo

}