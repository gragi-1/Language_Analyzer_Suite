Terminales = { boolean else float function if int let read return string void write floatconst intconst str idint idfl idbool idstr idfun pluseq eq comma semicolon oppar clpar opbra clbra sum and minorthan boolconst eof }

NoTerminales = { S AF AB A Tipo Id Igualar IgualarPre Descriptor Entero IntRecur TermInt TermInt2 Real FlRecur TermFl TermFl2 Booleano BoolRecur TermBool Cadena LlamarFuncion ArgPre ArgRec WriteAlt Cond ARec CondEl ElseAux DefFuncion Arg ArgAux AFuncion AFuncionVoid DefFuncionAux DescripFun Num If2 Else2 AIfPre ElseAux2 AIf IfVoid ElseVoid AIfPreVoid ElseAuxVoid AIfVoid EntComp FlComp CompIntAux CompFlAux }

Axioma = S

Producciones = {
S -> AF eof

AF -> AB AF
AF -> DefFuncion AF
AF -> lambda

AB -> A semicolon
AB -> if oppar Booleano clpar Cond

A -> let Tipo Id Igualar
A -> Id IgualarPre
A -> LlamarFuncion
A -> read Id
A -> write WriteAlt

Num -> Entero
Num -> Real

Tipo -> int
Tipo -> float
Tipo -> string
Tipo -> boolean

Id -> idint
Id -> idfl
Id -> idbool
Id -> idstr

IgualarPre -> Igualar
IgualarPre -> pluseq Num

Igualar -> eq Descriptor
Igualar -> lambda

Descriptor -> Num
Descriptor -> Booleano
Descriptor -> Cadena

Entero -> TermInt IntRecur

IntRecur -> sum TermInt2 IntRecur
IntRecur -> lambda

TermInt -> idint
TermInt -> intconst
TermInt -> LlamarFuncion sum TermInt2

TermInt2 -> idint
TermInt2 -> intconst
TermInt2 -> LlamarFuncion

Real -> TermFl FlRecur

FlRecur -> sum TermFl2 FlRecur
FlRecur -> lambda

TermFl -> idfl
TermFl -> floatconst
TermFl -> LlamarFuncion sum TermFl2

TermFl2 -> idfl
TermFl2 -> floatconst
TermFl2 -> LlamarFuncion

Booleano -> TermBool BoolRecur

BoolRecur -> and TermBool BoolRecur
BoolRecur -> lambda

TermBool -> idbool
TermBool -> boolconst
TermBool -> EntComp
TermBool -> FlComp
TermBool -> LlamarFuncion

EntComp -> TermInt IntRecur CompIntAux

CompIntAux -> minorthan TermInt IntRecur
CompIntAux -> lambda

FlComp -> TermFl FlRecur CompFlAux

CompFlAux -> minorthan TermFl FlRecur
CompFlAux -> lambda

Cadena -> idstr
Cadena -> str

LlamarFuncion -> idfun oppar ArgPre clpar

ArgPre -> Descriptor ArgRec
ArgPre -> lambda

ArgRec -> comma Descriptor ArgRec
ArgRec -> lambda

WriteAlt -> Descriptor
WriteAlt -> oppar Descriptor ArgRec clpar

Cond -> AB CondEl
Cond -> semicolon CondEl
Cond -> opbra ARec clbra CondEl

ARec -> AB ARec
ARec -> lambda

CondEl -> else ElseAux
CondEl -> lambda

ElseAux -> AB
ElseAux -> semicolon
ElseAux -> opbra ARec clbra

DefFuncion -> function DefFuncionAux clbra

DefFuncionAux -> Tipo DescripFun AFuncion
DefFuncionAux -> void DescripFun AFuncionVoid

DescripFun -> idfun oppar Arg clpar opbra

Arg -> Tipo Id ArgAux
Arg -> lambda

ArgAux -> comma Tipo Id ArgAux
ArgAux -> lambda

AFuncion -> A semicolon AFuncion
AFuncion -> if oppar Booleano clpar If2 AFuncion
AFuncion -> return Descriptor semicolon AFuncion
AFuncion -> lambda

AFuncionVoid -> A semicolon AFuncionVoid
AFuncionVoid -> if oppar Booleano clpar IfVoid AFuncionVoid
AFuncionVoid -> return semicolon AFuncionVoid
AFuncionVoid -> lambda

If2 -> AIfPre Else2
If2 -> opbra AIf clbra Else2

Else2 -> else ElseAux2
Else2 -> lambda

AIfPre -> A semicolon
AIfPre -> return Descriptor semicolon
AIfPre -> If2
AIfPre -> semicolon

AIf -> A semicolon AIf
AIf -> return Descriptor semicolon AIf
AIf -> If2 AIf
AIf -> semicolon AIf
AIf -> lambda

ElseAux2 -> opbra AIf clbra
ElseAux2 -> AIfPre

IfVoid -> AIfPreVoid ElseVoid
IfVoid -> opbra AIfVoid clbra ElseVoid

ElseVoid -> else ElseAuxVoid
ElseVoid -> lambda

AIfPreVoid -> A semicolon
AIfPreVoid -> return semicolon
AIfPreVoid -> IfVoid
AIfPreVoid -> semicolon

AIfVoid -> A semicolon AIfVoid
AIfVoid -> return semicolon AIfVoid
AIfVoid -> IfVoid AIfVoid
AIfVoid -> semicolon AIfVoid
AIfVoid -> lambda

ElseAuxVoid -> opbra AIfVoid clbra
ElseAuxVoid -> AIfPreVoid
}
